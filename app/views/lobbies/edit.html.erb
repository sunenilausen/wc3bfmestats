<% content_for :title, "Editing lobby" %>

<div class="flex gap-6" data-controller="lobby-drag">
  <div class="flex-1">
    <div class="flex items-center gap-4 mb-1">
      <h1 class="font-bold text-2xl">Editing lobby</h1>
      <%= link_to "View", @lobby, class: "text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded" %>
      <button type="button" id="balance-btn" onclick="balanceLobby()" class="text-sm px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded font-medium">
        ‚öñÔ∏è Auto-Balance
      </button>
      <button type="button" id="last-match-btn" onclick="populateFromLastMatch()" class="text-sm px-3 py-1 bg-green-500 hover:bg-green-600 text-white rounded font-medium">
        üìã Last Match
      </button>
      <button type="button" id="reset-btn" onclick="resetLobby()" class="text-sm px-3 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded font-medium">
        üóëÔ∏è Reset All
      </button>
      <span id="save-status" class="text-xs text-gray-400 hidden">Saving...</span>
    </div>

    <%= render partial: "lobby", locals: { lobby: @lobby, editable: true } %>
  </div>

  <div class="w-56 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Player Search</h2>

      <div class="mb-3">
        <input type="text"
               id="player-search-input"
               placeholder="Search by name..."
               class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
               onkeydown="if(event.key === 'Enter') event.preventDefault();">
      </div>

      <div id="player-search-results" class="space-y-1 h-[728px] overflow-y-auto">
        <!-- Results populated by JS -->
      </div>

      <p id="player-count" class="text-xs text-gray-400 mt-2"></p>
    </div>
  </div>

  <div class="w-80 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">28 Recent Players</h2>

      <div id="recent-players-list" class="grid grid-cols-2 gap-1 h-[780px]">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <div class="w-40 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Observers</h2>
      <p class="text-xs text-gray-500 mb-2">Click to remove</p>

      <div id="observers-list" class="space-y-1 max-h-[70vh] overflow-y-auto"
           data-lobby-drag-target="observerZone">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<script id="players-data" type="application/json">
  <%= raw @players_search_data.to_json %>
</script>

<script id="recent-players-data" type="application/json">
  <%= raw @recent_players.to_json %>
</script>

<script id="new-player-defaults" type="application/json">
  <%= raw @new_player_defaults.to_json %>
</script>

<script id="faction-stats-data" type="application/json">
  <%= raw @faction_stats.transform_keys { |k| "#{k[0]}_#{k[1]}" }.to_json %>
</script>

<script id="faction-rank-stats-data" type="application/json">
  <%= raw @faction_rank_stats.transform_keys { |k| "#{k[0]}_#{k[1]}" }.to_json %>
</script>

<script id="faction-perf-stats-data" type="application/json">
  <%= raw @faction_perf_stats.transform_keys { |k| "#{k[0]}_#{k[1]}" }.to_json %>
</script>

<script id="last-match-data" type="application/json">
  <%= raw @last_match_players.to_json %>
</script>

<script id="prediction-accuracy-data" type="application/json">
  <%= raw @prediction_accuracy_buckets.to_json %>
</script>

<style>
  .drop-zone-active {
    outline: 2px dashed #cbd5e1;
    outline-offset: -2px;
  }
  .drop-zone-hover {
    background-color: #dbeafe !important;
    outline-color: #3b82f6 !important;
  }
  .dragging {
    opacity: 0.5;
  }
  .already-assigned {
    opacity: 0.4;
    background-color: #f3f4f6 !important;
    cursor: default;
  }
  .player-card {
    cursor: pointer;
  }
  .player-card:not(.already-assigned):hover {
    background-color: #dbeafe;
    border-color: #3b82f6;
  }
</style>

<script>
  const allPlayers = JSON.parse(document.getElementById('players-data').textContent);
  const recentPlayers = JSON.parse(document.getElementById('recent-players-data').textContent);
  const newPlayerDefaults = JSON.parse(document.getElementById('new-player-defaults').textContent);
  const factionStats = JSON.parse(document.getElementById('faction-stats-data').textContent);
  const factionRankStats = JSON.parse(document.getElementById('faction-rank-stats-data').textContent);
  const factionPerfStats = JSON.parse(document.getElementById('faction-perf-stats-data').textContent);
  const lastMatchPlayers = JSON.parse(document.getElementById('last-match-data').textContent);
  const predictionAccuracyBuckets = JSON.parse(document.getElementById('prediction-accuracy-data').textContent);

  // Helper to get faction W/L for a player
  function getFactionWL(playerId, factionId) {
    const key = `${playerId}_${factionId}`;
    return factionStats[key] || { wins: 0, losses: 0 };
  }

  // Helper to get faction rank stats for a player
  function getFactionRankStats(playerId, factionId) {
    const key = `${playerId}_${factionId}`;
    return factionRankStats[key] || null;
  }

  // Helper to get faction performance score for a player
  function getFactionPerfScore(playerId, factionId) {
    const key = `${playerId}_${factionId}`;
    return factionPerfStats[key] || null;
  }

  // Helper to get color class for 0-centered performance scores
  function getPerfScoreColorClass(score) {
    if (score === null || score === undefined) return 'text-gray-600';
    if (score >= 5) return 'text-green-600';
    if (score <= -5) return 'text-red-600';
    return 'text-gray-600';
  }

  // Helper to format performance score with +/- sign
  function formatPerfScore(score) {
    if (score === null || score === undefined) return '-';
    return score >= 0 ? `+${score}` : `${score}`;
  }

  // Helper to get historical prediction accuracy for a confidence level
  function getPredictionAccuracy(confidencePct) {
    const bucketStart = Math.min(95, Math.max(50, Math.floor(confidencePct / 5) * 5));
    const bucketKey = `${bucketStart}-${bucketStart + 5}`;
    const bucket = predictionAccuracyBuckets[bucketKey];
    if (bucket && bucket.total > 0) {
      return { accuracy: bucket.accuracy, total: bucket.total, bucket: bucketKey };
    }
    return null;
  }

  // Special "New Player" option with default ratings
  const NEW_PLAYER = { id: 'new', nickname: `New Player (${newPlayerDefaults.ml_score})`, customRating: newPlayerDefaults.custom_rating, mlScore: newPlayerDefaults.ml_score, wins: 0, losses: 0, games: 0, isNew: true };

  function getAssignedPlayerIds() {
    const assignedIds = new Set();
    document.querySelectorAll('select[name*="player_id"]').forEach(select => {
      if (select.value) assignedIds.add(select.value);
    });
    const observerSelect = document.getElementById('observer-select');
    if (observerSelect) {
      Array.from(observerSelect.selectedOptions).forEach(opt => {
        assignedIds.add(opt.value);
      });
    }
    return assignedIds;
  }

  function renderRecentPlayers() {
    const assignedIds = getAssignedPlayerIds();
    const container = document.getElementById('recent-players-list');

    container.innerHTML = recentPlayers.map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = getPerfScoreColorClass(p.mlScore);
      const displayName = p.alternativeName ? `${p.nickname} (${p.alternativeName})` : p.nickname;
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${displayName}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${displayName.replace(/'/g, "\\'")}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}${p.alternativeName ? ` <span class="text-gray-400 font-normal">(${p.alternativeName})</span>` : ''}</span>
            <div class="flex items-center gap-1">
              <a href="/players/${p.id}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
              <span class="text-xs ${mlScoreColor} font-medium">${formatPerfScore(p.mlScore)}</span>
            </div>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.lastSeen || ''}</span>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderObservers() {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const container = document.getElementById('observers-list');
    const selectedObservers = Array.from(observerSelect.selectedOptions).map(opt => {
      const playerData = allPlayers.find(p => String(p.id) === opt.value);
      return {
        id: opt.value,
        nickname: opt.text,
        mlScore: playerData ? playerData.mlScore : null,
        wins: playerData ? playerData.wins : 0,
        losses: playerData ? playerData.losses : 0
      };
    });

    container.innerHTML = selectedObservers.map(p => {
      const mlScoreColor = getPerfScoreColorClass(p.mlScore);
      return `
      <div class="player-card p-2 bg-yellow-50 border border-yellow-200 rounded transition-colors cursor-move"
           draggable="true"
           data-player-id="${p.id}"
           data-player-name="${p.nickname}"
           data-source-type="observer"
           ondragstart="handleObserverDragStart(event, ${p.id}, '${p.nickname}')"
           ondragend="handlePlayerDragEnd(event)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm">${p.nickname}</span>
          <span class="text-xs ${mlScoreColor} font-medium">${formatPerfScore(p.mlScore)}</span>
        </div>
        <div class="flex justify-between items-center text-xs text-gray-500">
          <span>
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
          </span>
          <button type="button" onclick="removeObserver(${p.id})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </div>
      </div>
    `}).join('');

    if (selectedObservers.length === 0) {
      container.innerHTML = '<div class="p-4 border-2 border-dashed border-gray-300 rounded text-center text-xs text-gray-400 italic">Drag players here</div>';
    }
  }

  function removeObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && option.selected) {
      option.selected = false;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      submitFormWithTracking();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function addObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && !option.selected) {
      option.selected = true;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      submitFormWithTracking();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function renderPlayerResults() {
    const searchTerm = document.getElementById('player-search-input').value.toLowerCase();
    const assignedIds = getAssignedPlayerIds();

    const filtered = allPlayers.filter(p => {
      if (searchTerm) {
        const matchesNickname = p.nickname.toLowerCase().includes(searchTerm);
        const matchesAltName = p.alternativeName && p.alternativeName.toLowerCase().includes(searchTerm);
        if (!matchesNickname && !matchesAltName) return false;
      }
      return true;
    });

    const container = document.getElementById('player-search-results');

    // Add "New Player" card at the top
    let html = `
      <div class="player-card p-2 bg-green-50 border border-green-300 rounded transition-colors cursor-pointer hover:bg-green-100"
           draggable="true"
           data-player-id="new"
           data-player-name="New Player (${newPlayerDefaults.ml_score})"
           ondragstart="handleNewPlayerDragStart(event)"
           ondragend="handlePlayerDragEnd(event)"
           onclick="assignNewPlayer(this)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm text-green-700">+ New Player</span>
          <span class="text-xs ${getPerfScoreColorClass(newPlayerDefaults.ml_score)}">${formatPerfScore(newPlayerDefaults.ml_score)}</span>
        </div>
        <div class="text-xs text-green-600">Add unknown player</div>
      </div>
    `;

    html += filtered.slice(0, 50).map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = getPerfScoreColorClass(p.mlScore);
      const displayName = p.alternativeName ? `${p.nickname} (${p.alternativeName})` : p.nickname;
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${displayName}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${displayName.replace(/'/g, "\\'")}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}${p.alternativeName ? ` <span class="text-gray-400 font-normal">(${p.alternativeName})</span>` : ''}</span>
            <div class="flex items-center gap-1">
              <a href="/players/${p.id}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
              <span class="text-xs ${mlScoreColor} font-medium">${formatPerfScore(p.mlScore)}</span>
            </div>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.games}g</span>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;

    document.getElementById('player-count').textContent =
      `Showing ${Math.min(filtered.length, 50)} of ${filtered.length} players`;
  }

  function assignPlayer(playerId, element) {
    if (element.classList.contains('already-assigned')) return;

    // Find first empty slot
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        setSelectValue(select, String(playerId));

        // Trigger form submit with tracking
        submitFormWithTracking();

        // Update UI
        setTimeout(() => {
          renderPlayerResults();
          renderRecentPlayers();
          renderObservers();
        }, 100);
        return;
      }
    }

    // No empty slot - add as observer
    addObserver(playerId);
  }

  function assignNewPlayer(element) {
    // Find first empty slot and set it to "new player" mode
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        const slotIndex = slot.dataset.slotIndex;
        setNewPlayerSlot(slotIndex);
        return;
      }
    }
  }

  function setNewPlayerSlot(slotIndex) {
    // Clear the select value (no real player)
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Set the is_new_player hidden field
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '1';
    }

    // Update display to show "New Player" with bottom 5% ELO
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (cell) {
      const existingPlayer = cell.querySelector('.slot-player');
      const existingEmpty = cell.querySelector('.text-gray-400.italic');

      const html = `
        <span class="slot-player cursor-move px-2 py-1 bg-green-50 border border-green-300 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="new"
              data-player-name="New Player (${newPlayerDefaults.ml_score})"
              data-slot-index="${slotIndex}"
              data-is-new="true"
              data-ml-score="${newPlayerDefaults.ml_score}"
              ondragstart="handleSlotDragStart(event, 'new', 'New Player (${newPlayerDefaults.ml_score})', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          <span class="text-green-700">New Player</span>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;

      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    }

    // Set Performance Score, CR, W/L, and Rank to new player defaults
    const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
    const crCell = document.getElementById('cr-' + slotIndex);
    const wlCell = document.getElementById('wl-' + slotIndex);
    const facWlCell = document.getElementById('fac-wl-' + slotIndex);
    const rankCell = document.getElementById('rank-' + slotIndex);
    const facRankCell = document.getElementById('fac-rank-' + slotIndex);

    if (mlScoreCell) mlScoreCell.innerHTML = `<span class="${getPerfScoreColorClass(newPlayerDefaults.ml_score)} font-medium">${formatPerfScore(newPlayerDefaults.ml_score)}</span>`;
    if (crCell) crCell.textContent = newPlayerDefaults.custom_rating || 1300;
    if (wlCell) wlCell.innerHTML = '<span class="text-gray-400">0/0</span>';
    if (facWlCell) facWlCell.innerHTML = '<span class="text-gray-400">0/0</span>';
    if (rankCell) rankCell.innerHTML = '<span class="text-gray-400">4.5</span>';
    if (facRankCell) facRankCell.innerHTML = '<span class="text-gray-400">-</span>';

    // Mark this slot as a new player for prediction calculations
    const row = cell.closest('tr');
    if (row) row.dataset.isNewPlayer = 'true';

    // Submit the form to save the new player state
    submitFormWithTracking();

    // Update averages and prediction
    updateAverageElos();
    updatePrediction();
  }

  function handleNewPlayerDragStart(e) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: 'new',
      playerName: `New Player (${newPlayerDefaults.ml_score})`,
      sourceType: 'new',
      isNew: true
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function setSelectValue(select, value) {
    select.value = value;

    // Clear is_new_player when assigning a real player
    const slotIndex = select.id.replace('player-select-', '');
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '0';
    }

    // Remove new player marker from row
    const row = select.closest('tr');
    if (row) delete row.dataset.isNewPlayer;

    // Update searchable-select display
    const wrapper = select.previousElementSibling;
    if (wrapper && wrapper.classList.contains('searchable-select')) {
      const input = wrapper.querySelector('.searchable-select-input');
      if (input) {
        const selectedOption = select.options[select.selectedIndex];
        input.value = selectedOption ? selectedOption.text : '';
      }
    }

    // Trigger change and update W/L
    select.dispatchEvent(new Event('change', { bubbles: true }));
    const wlTarget = select.dataset.wlTarget;
    if (wlTarget && typeof updateWL === 'function') {
      updateWL(select, wlTarget);
    }
  }

  function refreshObserverSelect() {
    // No longer needed since we use a hidden select now
    // Kept for compatibility
  }

  function updateWL(select, targetId) {
    const option = select.options[select.selectedIndex];
    const playerId = option.value;
    const factionId = select.dataset.factionId;
    const mlScore = option.dataset.mlScore;
    const wins = option.dataset.wins;
    const losses = option.dataset.losses;
    const wlTarget = document.getElementById(targetId);
    const facWlTarget = document.getElementById(targetId.replace('wl-', 'fac-wl-'));
    const mlScoreTarget = document.getElementById(targetId.replace('wl-', 'ml-score-'));

    // Overall W/L
    if (wins !== undefined && losses !== undefined && wins !== '' && losses !== '') {
      wlTarget.innerHTML = `<span class="text-green-600">${wins}</span>/<span class="text-red-600">${losses}</span>`;
    } else {
      wlTarget.innerHTML = '-';
    }

    // Faction-specific W/L
    if (facWlTarget) {
      if (playerId && factionId) {
        const facWL = getFactionWL(playerId, factionId);
        facWlTarget.innerHTML = `<span class="text-green-600">${facWL.wins}</span>/<span class="text-red-600">${facWL.losses}</span>`;
      } else {
        facWlTarget.innerHTML = '-';
      }
    }

    if (mlScoreTarget && mlScore) {
      const score = parseFloat(mlScore);
      const colorClass = getPerfScoreColorClass(score);
      mlScoreTarget.innerHTML = `<span class="${colorClass} font-medium">${formatPerfScore(Math.round(score))}</span>`;
    } else if (mlScoreTarget) {
      mlScoreTarget.innerHTML = '-';
    }
    updateAverageElos();
    updatePrediction();
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
  }

  function updateAverageElos() {
    // Recalculate average Performance Score and CR for each team
    [1, 2].forEach(teamNumber => {
      const rows = document.querySelectorAll(`tr.nested-fields[data-team="${teamNumber}"]`);
      let totalMlScore = 0;
      let totalCR = 0;
      let count = 0;
      rows.forEach(row => {
        const select = row.querySelector('select');
        const isNewPlayer = row.dataset.isNewPlayer === 'true';

        if (isNewPlayer) {
          totalMlScore += newPlayerDefaults.ml_score;
          totalCR += newPlayerDefaults.custom_rating || 1300;
          count++;
        } else if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            const mlScore = parseFloat(selectedOption.dataset.mlScore);
            const cr = parseFloat(selectedOption.dataset.customRating) || 1300;
            if (!isNaN(mlScore)) {
              totalMlScore += mlScore;
              totalCR += cr;
              count++;
            }
          }
        }
      });
      const averageMlScore = count > 0 ? (totalMlScore / count).toFixed(1) : 0;
      const averageCR = count > 0 ? Math.round(totalCR / count) : 0;

      // Find the average display for this team's tbody
      const tbody = document.querySelector(`tbody[data-controller="average-elo"]:nth-of-type(${teamNumber})`);
      if (tbody) {
        const mlValueTarget = tbody.querySelector('[data-average-elo-target="mlValue"]');
        if (mlValueTarget) {
          mlValueTarget.textContent = averageMlScore;
        }
        const crValueTarget = tbody.querySelector('[data-average-elo-target="crValue"]');
        if (crValueTarget) {
          crValueTarget.textContent = averageCR;
        }
      }
    });
  }

  // Prediction constants (matching LobbyWinPredictor service)
  const GAMES_FOR_FULL_CR_TRUST = 30;
  const MAX_ML_CR_ADJUSTMENT = 200;
  const ML_BASELINE = 0;  // 0-centered scale (0 = average)

  // Calculate effective CR with ML score adjustment for new players
  // Only applies penalty for new players with ML score < 0 (below average)
  // No bonus for any new player - trust their CR if they perform well
  function calculateEffectiveCR(cr, games, mlScore) {
    if (games >= GAMES_FOR_FULL_CR_TRUST) {
      return cr;
    }

    // Only apply penalty if ML score is below baseline (0)
    // No bonus for new players at or above 0
    if (mlScore >= ML_BASELINE) {
      return cr;
    }

    // ML score deviation from baseline (negative only at this point)
    const mlDeviation = mlScore - ML_BASELINE;

    // Penalty scales down as games increase
    const adjustmentFactor = 1.0 - (games / GAMES_FOR_FULL_CR_TRUST);

    // Scale deviation to CR adjustment (max -200 for ML score -50)
    const mlCRAdjustment = (mlDeviation / 50.0) * MAX_ML_CR_ADJUSTMENT * adjustmentFactor;

    return cr + mlCRAdjustment;
  }

  function updatePrediction() {
    const rows = document.querySelectorAll('tr.nested-fields');
    let goodEffectiveCRs = [];
    let evilEffectiveCRs = [];
    let goodCRs = [];
    let evilCRs = [];
    let goodMLScores = [];
    let evilMLScores = [];
    let goodFacPerfs = [];
    let evilFacPerfs = [];
    let goodOverallRanks = [];
    let evilOverallRanks = [];
    let goodFacRanks = [];
    let evilFacRanks = [];

    rows.forEach(row => {
      const team = row.dataset.team;
      if (!team) return;

      const isNewPlayer = row.dataset.isNewPlayer === 'true';
      let cr = null;
      let mlScore = null;
      let games = 0;
      let playerId = null;
      let factionId = null;

      // Get faction ID from hidden input
      const factionInput = row.querySelector('input[name*="[faction_id]"]');
      if (factionInput) factionId = parseInt(factionInput.value);

      if (isNewPlayer) {
        cr = newPlayerDefaults.custom_rating || 1300;
        mlScore = newPlayerDefaults.ml_score || 35;
        games = 0;
      } else {
        const select = row.querySelector('select');
        if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.value) {
            playerId = parseInt(selectedOption.value);
            cr = parseFloat(selectedOption.dataset.customRating) || 1300;
            mlScore = parseFloat(selectedOption.dataset.mlScore) || 50;
            games = parseInt(selectedOption.dataset.games) || 0;
          }
        }
      }

      if (cr !== null && !isNaN(cr)) {
        const effectiveCR = calculateEffectiveCR(cr, games, mlScore);

        // Get faction-specific perf and rank if we have a player
        let facPerf = null;
        let overallRank = null;
        let facRank = null;

        if (playerId && factionId) {
          facPerf = getFactionPerfScore(playerId, factionId);
          const facRankData = getFactionRankStats(playerId, factionId);
          if (facRankData) facRank = facRankData.avg;
          // Get overall rank from players search data
          const playerData = allPlayers.find(p => p.id === playerId);
          if (playerData) overallRank = playerData.avgRank;
        }

        if (team === '1') {
          goodEffectiveCRs.push(effectiveCR);
          goodCRs.push(cr);
          goodMLScores.push(mlScore);
          if (facPerf !== null) goodFacPerfs.push(facPerf);
          if (overallRank !== null) goodOverallRanks.push(overallRank);
          if (facRank !== null) goodFacRanks.push(facRank);
        } else if (team === '2') {
          evilEffectiveCRs.push(effectiveCR);
          evilCRs.push(cr);
          evilMLScores.push(mlScore);
          if (facPerf !== null) evilFacPerfs.push(facPerf);
          if (overallRank !== null) evilOverallRanks.push(overallRank);
          if (facRank !== null) evilFacRanks.push(facRank);
        }
      }
    });

    // Calculate average effective CRs
    const goodAvgEffectiveCR = goodEffectiveCRs.length > 0 ? goodEffectiveCRs.reduce((a, b) => a + b, 0) / goodEffectiveCRs.length : 1300;
    const evilAvgEffectiveCR = evilEffectiveCRs.length > 0 ? evilEffectiveCRs.reduce((a, b) => a + b, 0) / evilEffectiveCRs.length : 1300;

    // Convert CR difference to win probability
    // 100 CR difference ‚âà 64% win chance for higher rated team
    const crDiff = goodAvgEffectiveCR - evilAvgEffectiveCR;
    const goodExpected = 1 / (1 + Math.exp(-crDiff / 150.0));
    const goodPct = Math.round(goodExpected * 100);
    const evilPct = 100 - goodPct;

    // Calculate averages for display
    const goodCRAvg = goodCRs.length > 0 ? goodCRs.reduce((a, b) => a + b, 0) / goodCRs.length : 1300;
    const evilCRAvg = evilCRs.length > 0 ? evilCRs.reduce((a, b) => a + b, 0) / evilCRs.length : 1300;
    const goodMLAvg = goodMLScores.length > 0 ? goodMLScores.reduce((a, b) => a + b, 0) / goodMLScores.length : 50;
    const evilMLAvg = evilMLScores.length > 0 ? evilMLScores.reduce((a, b) => a + b, 0) / evilMLScores.length : 50;

    // Update combined prediction bar
    const combinedBar = document.getElementById('combined-win-bar');
    const combinedGoodPct = document.getElementById('combined-good-pct');
    const combinedEvilPct = document.getElementById('combined-evil-pct');

    if (combinedBar) combinedBar.style.width = goodPct + '%';
    if (combinedGoodPct) combinedGoodPct.textContent = goodPct + '%';
    if (combinedEvilPct) combinedEvilPct.textContent = evilPct + '%';

    // Update historical accuracy label
    const accuracyLabel = document.getElementById('prediction-accuracy-label');
    if (accuracyLabel) {
      const confidencePct = Math.max(goodPct, evilPct);
      const accuracy = getPredictionAccuracy(confidencePct);
      if (accuracy) {
        accuracyLabel.innerHTML = `Historical: <span class="font-medium">${accuracy.accuracy}%</span> accurate`;
        accuracyLabel.title = `Based on ${accuracy.total} historical matches with ${accuracy.bucket}% confidence`;
        accuracyLabel.classList.remove('text-gray-400');
        accuracyLabel.classList.add('text-gray-500');
      } else {
        accuracyLabel.textContent = 'CR+ (improved for new players)';
        accuracyLabel.title = '';
        accuracyLabel.classList.remove('text-gray-500');
        accuracyLabel.classList.add('text-gray-400');
      }
    }

    // Update detail display
    const predGoodCR = document.getElementById('pred-good-cr');
    const predEvilCR = document.getElementById('pred-evil-cr');
    const predGoodRank = document.getElementById('pred-good-rank');
    const predEvilRank = document.getElementById('pred-evil-rank');

    if (predGoodCR) predGoodCR.textContent = Math.round(goodAvgEffectiveCR);
    if (predEvilCR) predEvilCR.textContent = Math.round(evilAvgEffectiveCR);
    // Show ML avg instead of rank score now
    if (predGoodRank) predGoodRank.textContent = Math.round(goodMLAvg);
    if (predEvilRank) predEvilRank.textContent = Math.round(evilMLAvg);

    // Update team average faction PERF displays
    const goodAvgFacPerfEl = document.getElementById('good-avg-fac-perf');
    const evilAvgFacPerfEl = document.getElementById('evil-avg-fac-perf');
    if (goodAvgFacPerfEl) {
      if (goodFacPerfs.length > 0) {
        const avgFacPerf = Math.round(goodFacPerfs.reduce((a, b) => a + b, 0) / goodFacPerfs.length);
        goodAvgFacPerfEl.textContent = '/' + formatPerfScore(avgFacPerf);
      } else {
        goodAvgFacPerfEl.textContent = '';
      }
    }
    if (evilAvgFacPerfEl) {
      if (evilFacPerfs.length > 0) {
        const avgFacPerf = Math.round(evilFacPerfs.reduce((a, b) => a + b, 0) / evilFacPerfs.length);
        evilAvgFacPerfEl.textContent = '/' + formatPerfScore(avgFacPerf);
      } else {
        evilAvgFacPerfEl.textContent = '';
      }
    }

    // Update team average rank displays (overall/faction)
    const goodAvgOverallRankEl = document.getElementById('good-avg-overall-rank');
    const goodAvgFacRankEl = document.getElementById('good-avg-fac-rank');
    const evilAvgOverallRankEl = document.getElementById('evil-avg-overall-rank');
    const evilAvgFacRankEl = document.getElementById('evil-avg-fac-rank');

    if (goodAvgOverallRankEl) {
      if (goodOverallRanks.length > 0) {
        const avgRank = (goodOverallRanks.reduce((a, b) => a + b, 0) / goodOverallRanks.length).toFixed(1);
        goodAvgOverallRankEl.textContent = avgRank;
        goodAvgOverallRankEl.className = avgRank <= 2.5 ? 'text-green-600' : (avgRank >= 3.5 ? 'text-red-600' : '');
      } else {
        goodAvgOverallRankEl.textContent = '';
        goodAvgOverallRankEl.className = '';
      }
    }
    if (goodAvgFacRankEl) {
      if (goodFacRanks.length > 0) {
        const avgFacRank = (goodFacRanks.reduce((a, b) => a + b, 0) / goodFacRanks.length).toFixed(1);
        goodAvgFacRankEl.textContent = '/' + avgFacRank;
      } else {
        goodAvgFacRankEl.textContent = '';
      }
    }
    if (evilAvgOverallRankEl) {
      if (evilOverallRanks.length > 0) {
        const avgRank = (evilOverallRanks.reduce((a, b) => a + b, 0) / evilOverallRanks.length).toFixed(1);
        evilAvgOverallRankEl.textContent = avgRank;
        evilAvgOverallRankEl.className = avgRank <= 2.5 ? 'text-green-600' : (avgRank >= 3.5 ? 'text-red-600' : '');
      } else {
        evilAvgOverallRankEl.textContent = '';
        evilAvgOverallRankEl.className = '';
      }
    }
    if (evilAvgFacRankEl) {
      if (evilFacRanks.length > 0) {
        const avgFacRank = (evilFacRanks.reduce((a, b) => a + b, 0) / evilFacRanks.length).toFixed(1);
        evilAvgFacRankEl.textContent = '/' + avgFacRank;
      } else {
        evilAvgFacRankEl.textContent = '';
      }
    }
  }

  // Drag handlers
  function handlePlayerDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'search'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function handleObserverDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'observer'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight only player slots (not observer zone since they're already observers)
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function handleSlotDragStart(e, playerId, playerName, slotIndex) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'slot',
      sourceIndex: slotIndex
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight all drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function clearSlot(slotIndex) {
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));

      // Clear the is_new_player hidden field
      const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
      if (isNewPlayerField) {
        isNewPlayerField.value = '0';
      }

      // Update the cell display
      updateSlotDisplay(slotIndex, null, null);

      // Remove new player marker if present
      const cell = document.getElementById('player-cell-' + slotIndex);
      const row = cell?.closest('tr');
      if (row) delete row.dataset.isNewPlayer;

      // Trigger form submit with tracking
      submitFormWithTracking();

      // Update all lists
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
        updateAverageElos();
        updatePrediction();
      }, 100);
    }
  }

  function updateSlotDisplay(slotIndex, playerId, playerName) {
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (!cell) return;

    // Find existing slot-player span or empty slot text
    const existingPlayer = cell.querySelector('.slot-player');
    const existingEmpty = cell.querySelector('.text-gray-400.italic');

    if (playerId && playerName) {
      const html = `
        <span class="slot-player cursor-move px-4 py-2 bg-blue-50 border border-blue-200 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="${playerId}"
              data-player-name="${playerName}"
              data-slot-index="${slotIndex}"
              ondragstart="handleSlotDragStart(event, ${playerId}, '${playerName}', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          ${playerName}
          <a href="/players/${playerId}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
            </svg>
          </a>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    } else {
      const html = '<span class="text-gray-400 italic">Empty slot</span>';
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      }
    }

    // Update Performance Score, CR, and W/L display
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      const option = select.options[select.selectedIndex];
      const playerId = option ? option.value : null;
      const factionId = select.dataset.factionId;
      const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
      const crCell = document.getElementById('cr-' + slotIndex);
      const wlCell = document.getElementById('wl-' + slotIndex);
      const facWlCell = document.getElementById('fac-wl-' + slotIndex);

      if (mlScoreCell) {
        if (option && option.dataset.mlScore) {
          const score = parseFloat(option.dataset.mlScore);
          const colorClass = getPerfScoreColorClass(score);
          let html = `<span class="${colorClass} font-medium">${formatPerfScore(Math.round(score))}</span>`;
          // Add faction perf if available
          if (playerId && factionId) {
            const facPerf = getFactionPerfScore(playerId, factionId);
            if (facPerf) {
              html += `<span class="text-gray-400">/${formatPerfScore(facPerf)}</span>`;
            }
          }
          mlScoreCell.innerHTML = html;
        } else {
          mlScoreCell.textContent = '-';
        }
      }
      // Custom Rating
      if (crCell) {
        if (option && option.dataset.customRating) {
          crCell.textContent = option.dataset.customRating;
        } else {
          crCell.textContent = '-';
        }
      }
      // Overall W/L
      if (wlCell) {
        if (option && option.dataset.wins !== undefined && option.dataset.losses !== undefined) {
          wlCell.innerHTML = `<span class="text-green-600">${option.dataset.wins}</span>/<span class="text-red-600">${option.dataset.losses}</span>`;
        } else {
          wlCell.textContent = '-';
        }
      }
      // Faction W/L
      if (facWlCell) {
        if (playerId && factionId) {
          const facWL = getFactionWL(playerId, factionId);
          facWlCell.innerHTML = `<span class="text-green-600">${facWL.wins}</span>/<span class="text-red-600">${facWL.losses}</span>`;
        } else {
          facWlCell.textContent = '-';
        }
      }

      // Combined Rank (overall/faction)
      const rankCell = document.getElementById('rank-' + slotIndex);
      if (rankCell) {
        if (option && option.dataset.avgRank) {
          const avgRank = parseFloat(option.dataset.avgRank);
          const colorClass = avgRank <= 2.5 ? 'text-green-600' : (avgRank >= 3.5 ? 'text-red-600' : '');
          let html = `<span class="${colorClass}">${avgRank.toFixed(1)}</span>`;
          // Add faction rank if available
          if (playerId && factionId) {
            const facData = getFactionRankStats(playerId, factionId);
            if (facData) {
              html += `<span class="text-gray-400">/${facData.avg.toFixed(1)}</span>`;
            }
          }
          rankCell.innerHTML = html;
        } else {
          rankCell.innerHTML = '<span class="text-gray-400">-</span>';
        }
      }

      // Leave %
      const leaveCell = document.getElementById('leave-' + slotIndex);
      if (leaveCell) {
        if (option && option.dataset.leavePct !== undefined) {
          const leavePct = parseFloat(option.dataset.leavePct);
          const gamesLeft = parseInt(option.dataset.gamesLeft) || 0;
          const colorClass = leavePct === 0 ? 'text-green-600' : (leavePct >= 20 ? 'text-red-600' : 'text-yellow-600');
          let html = `<span class="${colorClass}">${leavePct}%</span>`;
          if (gamesLeft > 0) {
            html += ` <span class="text-gray-400 text-xs">(${gamesLeft})</span>`;
          }
          leaveCell.innerHTML = html;
        } else {
          leaveCell.textContent = '-';
        }
      }
    }
  }

  function handlePlayerDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.remove('drop-zone-active', 'drop-zone-hover');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.remove('drop-zone-active', 'drop-zone-hover');
  }

  // Expose functions to window for Stimulus controller
  window.setSelectValue = setSelectValue;
  window.refreshObserverSelect = refreshObserverSelect;
  window.renderPlayerResults = renderPlayerResults;
  window.renderRecentPlayers = renderRecentPlayers;
  window.renderObservers = renderObservers;
  window.addObserver = addObserver;
  window.removeObserver = removeObserver;
  window.clearSlot = clearSlot;
  window.updateSlotDisplay = updateSlotDisplay;
  window.updateAverageElos = updateAverageElos;
  window.updatePrediction = updatePrediction;
  window.handlePlayerDragStart = handlePlayerDragStart;
  window.handleObserverDragStart = handleObserverDragStart;
  window.handleSlotDragStart = handleSlotDragStart;
  window.handlePlayerDragEnd = handlePlayerDragEnd;
  window.handleNewPlayerDragStart = handleNewPlayerDragStart;
  window.assignNewPlayer = assignNewPlayer;
  window.setNewPlayerSlot = setNewPlayerSlot;

  // Track pending form submissions
  let pendingSavePromise = null;
  let pendingSaveResolve = null;

  function showSaveStatus(show) {
    const status = document.getElementById('save-status');
    if (status) {
      status.classList.toggle('hidden', !show);
    }
  }

  // Submit form and track the save
  function submitFormWithTracking() {
    const form = document.getElementById('lobby-form');
    if (!form) return;

    showSaveStatus(true);

    // Create promise if not already pending
    if (!pendingSavePromise) {
      pendingSavePromise = new Promise((resolve) => {
        pendingSaveResolve = resolve;
      });
    }

    form.requestSubmit();
  }

  // Listen for form submission completion
  document.addEventListener('turbo:submit-end', () => {
    showSaveStatus(false);
    if (pendingSaveResolve) {
      // Small delay to ensure server has fully processed
      setTimeout(() => {
        pendingSaveResolve();
        pendingSavePromise = null;
        pendingSaveResolve = null;
      }, 100);
    }
  });

  // Wait for any pending saves
  async function waitForPendingSaves() {
    if (pendingSavePromise) {
      await pendingSavePromise;
    }
    // Extra small delay to be safe
    await new Promise(r => setTimeout(r, 150));
  }

  // Show toast notification
  function showToast(message, duration = 8000) {
    // Remove any existing toast
    const existingToast = document.getElementById('balance-toast');
    if (existingToast) existingToast.remove();

    const toast = document.createElement('div');
    toast.id = 'balance-toast';
    toast.className = 'fixed top-20 right-4 z-50 bg-green-600 text-white px-4 py-3 rounded-lg shadow-lg max-w-md';
    toast.innerHTML = `
      <div class="flex items-start gap-3">
        <div class="flex-1">
          <div class="font-medium mb-1">Auto-Balance Complete</div>
          <div class="text-sm text-green-100">${message}</div>
        </div>
        <button onclick="this.parentElement.parentElement.remove()" class="text-green-200 hover:text-white text-xl leading-none">&times;</button>
      </div>
    `;
    document.body.appendChild(toast);

    // Auto-dismiss after duration
    setTimeout(() => {
      if (toast.parentElement) {
        toast.style.transition = 'opacity 0.3s';
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
      }
    }, duration);
  }

  // Check for stored swap message on page load
  function checkForSwapMessage() {
    const swapMessage = sessionStorage.getItem('balanceSwapMessage');
    if (swapMessage) {
      sessionStorage.removeItem('balanceSwapMessage');
      showToast(swapMessage);
    }
  }

  // Balance lobby function
  async function balanceLobby() {
    const btn = document.getElementById('balance-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Saving...';

    try {
      // Wait for any pending form submissions
      await waitForPendingSaves();

      btn.innerHTML = '‚è≥ Balancing...';

      const response = await fetch('<%= balance_lobby_path(@lobby) %>', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      const result = await response.json();

      if (result.success) {
        if (result.swaps_count > 0) {
          // Build swap message
          const swapMessages = result.swap_details.map(swap =>
            `${swap.player1} (${swap.faction1}) ‚Üî ${swap.player2} (${swap.faction2})`
          );
          const message = swapMessages.join('<br>');

          // Store message for after reload
          sessionStorage.setItem('balanceSwapMessage', message);

          // Reload the page to show updated lobby
          window.location.reload();
        } else {
          btn.innerHTML = '‚úì Already balanced';
          setTimeout(() => { btn.innerHTML = originalText; btn.disabled = false; }, 2000);
        }
      } else {
        alert('Balance failed: ' + result.message);
        btn.innerHTML = originalText;
        btn.disabled = false;
      }
    } catch (error) {
      alert('Balance failed: ' + error.message);
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }
  window.balanceLobby = balanceLobby;

  // Populate lobby from last match
  async function populateFromLastMatch() {
    if (Object.keys(lastMatchPlayers).length === 0) {
      alert('No recent match found');
      return;
    }

    const btn = document.getElementById('last-match-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Loading...';

    try {
      // Wait for any pending saves first
      await waitForPendingSaves();

      // Set each player select to the corresponding player from the last match
      document.querySelectorAll('select[name*="player_id"]').forEach(select => {
        const factionId = select.dataset.factionId;
        const playerId = lastMatchPlayers[factionId];

        if (playerId) {
          select.value = String(playerId);
        } else {
          select.value = '';
        }

        // Clear is_new_player flag
        const slotIndex = select.id.replace('player-select-', '');
        const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
        if (isNewPlayerField) {
          isNewPlayerField.value = '0';
        }
      });

      // Submit the form and wait
      submitFormWithTracking();
      await waitForPendingSaves();

      // Reload to get fresh state
      window.location.reload();
    } catch (error) {
      alert('Failed to load last match: ' + error.message);
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }
  window.populateFromLastMatch = populateFromLastMatch;

  // Reset lobby - clear all player slots
  async function resetLobby() {
    if (!confirm('Clear all players from this lobby?')) return;

    const btn = document.getElementById('reset-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Resetting...';

    try {
      // Clear all player selects
      document.querySelectorAll('select[name*="player_id"]').forEach(select => {
        select.value = '';
      });

      // Clear all is_new_player hidden fields
      document.querySelectorAll('input[name*="is_new_player"]').forEach(input => {
        input.value = '0';
      });

      // Clear observers
      const observerSelect = document.getElementById('observer-select');
      if (observerSelect) {
        Array.from(observerSelect.options).forEach(opt => opt.selected = false);
      }

      // Submit the form and wait for it to complete
      submitFormWithTracking();
      await waitForPendingSaves();

      // Reload to get fresh state
      window.location.reload();
    } catch (error) {
      alert('Reset failed: ' + error.message);
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }
  window.resetLobby = resetLobby;
  window.submitFormWithTracking = submitFormWithTracking;

  // Event listeners
  document.getElementById('player-search-input').addEventListener('input', renderPlayerResults);

  // Also update when selects change
  document.addEventListener('change', (e) => {
    if (e.target.matches('select[name*="player_id"]') || e.target.id === 'observer-select') {
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 50);
    }
  });

  document.addEventListener('DOMContentLoaded', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
    checkForSwapMessage();
  });
  document.addEventListener('turbo:load', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
    checkForSwapMessage();
  });
</script>
