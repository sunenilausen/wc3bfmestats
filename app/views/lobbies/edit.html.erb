<% content_for :title, "Editing lobby" %>

<div class="flex gap-6" data-controller="lobby-drag">
  <div class="flex-1">
    <div class="flex items-center gap-4 mb-1">
      <h1 class="font-bold text-2xl">Editing lobby</h1>
      <%= link_to "View", @lobby, class: "text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded" %>
      <button type="button" id="balance-btn" onclick="balanceLobby()" class="text-sm px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded font-medium">
        ‚öñÔ∏è Auto-Balance
      </button>
      <button type="button" id="reset-btn" onclick="resetLobby()" class="text-sm px-3 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded font-medium">
        üóëÔ∏è Reset All
      </button>
      <span id="save-status" class="text-xs text-gray-400 hidden">Saving...</span>
    </div>

    <%= render partial: "lobby", locals: { lobby: @lobby, editable: true } %>
  </div>

  <div class="w-56 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Player Search</h2>

      <div class="mb-3">
        <input type="text"
               id="player-search-input"
               placeholder="Search by name..."
               class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      </div>

      <div id="player-search-results" class="space-y-1 h-[728px] overflow-y-auto">
        <!-- Results populated by JS -->
      </div>

      <p id="player-count" class="text-xs text-gray-400 mt-2"></p>
    </div>
  </div>

  <div class="w-80 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">28 Recent Players</h2>

      <div id="recent-players-list" class="grid grid-cols-2 gap-1 h-[780px]">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <div class="w-40 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Observers</h2>
      <p class="text-xs text-gray-500 mb-2">Click to remove</p>

      <div id="observers-list" class="space-y-1 max-h-[70vh] overflow-y-auto"
           data-lobby-drag-target="observerZone">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<script id="players-data" type="application/json">
  <%= raw @players_search_data.to_json %>
</script>

<script id="recent-players-data" type="application/json">
  <%= raw @recent_players.to_json %>
</script>

<script id="new-player-defaults" type="application/json">
  <%= raw @new_player_defaults.to_json %>
</script>

<script id="faction-stats-data" type="application/json">
  <%= raw @faction_stats.transform_keys { |k| "#{k[0]}_#{k[1]}" }.to_json %>
</script>

<style>
  .drop-zone-active {
    outline: 2px dashed #cbd5e1;
    outline-offset: -2px;
  }
  .drop-zone-hover {
    background-color: #dbeafe !important;
    outline-color: #3b82f6 !important;
  }
  .dragging {
    opacity: 0.5;
  }
  .already-assigned {
    opacity: 0.4;
    background-color: #f3f4f6 !important;
    cursor: default;
  }
  .player-card {
    cursor: pointer;
  }
  .player-card:not(.already-assigned):hover {
    background-color: #dbeafe;
    border-color: #3b82f6;
  }
</style>

<script>
  const allPlayers = JSON.parse(document.getElementById('players-data').textContent);
  const recentPlayers = JSON.parse(document.getElementById('recent-players-data').textContent);
  const newPlayerDefaults = JSON.parse(document.getElementById('new-player-defaults').textContent);
  const factionStats = JSON.parse(document.getElementById('faction-stats-data').textContent);

  // Helper to get faction W/L for a player
  function getFactionWL(playerId, factionId) {
    const key = `${playerId}_${factionId}`;
    return factionStats[key] || { wins: 0, losses: 0 };
  }

  // Special "New Player" option with default ratings
  const NEW_PLAYER = { id: 'new', nickname: `New Player (${newPlayerDefaults.ml_score})`, customRating: newPlayerDefaults.custom_rating, mlScore: newPlayerDefaults.ml_score, wins: 0, losses: 0, games: 0, isNew: true };

  function getAssignedPlayerIds() {
    const assignedIds = new Set();
    document.querySelectorAll('select[name*="player_id"]').forEach(select => {
      if (select.value) assignedIds.add(select.value);
    });
    const observerSelect = document.getElementById('observer-select');
    if (observerSelect) {
      Array.from(observerSelect.selectedOptions).forEach(opt => {
        assignedIds.add(opt.value);
      });
    }
    return assignedIds;
  }

  function renderRecentPlayers() {
    const assignedIds = getAssignedPlayerIds();
    const container = document.getElementById('recent-players-list');

    container.innerHTML = recentPlayers.map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      const displayName = p.alternativeName ? `${p.nickname} (${p.alternativeName})` : p.nickname;
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${displayName}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${displayName.replace(/'/g, "\\'")}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}${p.alternativeName ? ` <span class="text-gray-400 font-normal">(${p.alternativeName})</span>` : ''}</span>
            <div class="flex items-center gap-1">
              <a href="/players/${p.id}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
              <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
            </div>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.lastSeen || ''}</span>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderObservers() {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const container = document.getElementById('observers-list');
    const selectedObservers = Array.from(observerSelect.selectedOptions).map(opt => {
      const playerData = allPlayers.find(p => String(p.id) === opt.value);
      return {
        id: opt.value,
        nickname: opt.text,
        mlScore: playerData ? playerData.mlScore : null,
        wins: playerData ? playerData.wins : 0,
        losses: playerData ? playerData.losses : 0
      };
    });

    container.innerHTML = selectedObservers.map(p => {
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
      <div class="player-card p-2 bg-yellow-50 border border-yellow-200 rounded transition-colors cursor-move"
           draggable="true"
           data-player-id="${p.id}"
           data-player-name="${p.nickname}"
           data-source-type="observer"
           ondragstart="handleObserverDragStart(event, ${p.id}, '${p.nickname}')"
           ondragend="handlePlayerDragEnd(event)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm">${p.nickname}</span>
          <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
        </div>
        <div class="flex justify-between items-center text-xs text-gray-500">
          <span>
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
          </span>
          <button type="button" onclick="removeObserver(${p.id})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </div>
      </div>
    `}).join('');

    if (selectedObservers.length === 0) {
      container.innerHTML = '<div class="p-4 border-2 border-dashed border-gray-300 rounded text-center text-xs text-gray-400 italic">Drag players here</div>';
    }
  }

  function removeObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && option.selected) {
      option.selected = false;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      submitFormWithTracking();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function addObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && !option.selected) {
      option.selected = true;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      submitFormWithTracking();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function renderPlayerResults() {
    const searchTerm = document.getElementById('player-search-input').value.toLowerCase();
    const assignedIds = getAssignedPlayerIds();

    const filtered = allPlayers.filter(p => {
      if (searchTerm) {
        const matchesNickname = p.nickname.toLowerCase().includes(searchTerm);
        const matchesAltName = p.alternativeName && p.alternativeName.toLowerCase().includes(searchTerm);
        if (!matchesNickname && !matchesAltName) return false;
      }
      return true;
    });

    const container = document.getElementById('player-search-results');

    // Add "New Player" card at the top
    let html = `
      <div class="player-card p-2 bg-green-50 border border-green-300 rounded transition-colors cursor-pointer hover:bg-green-100"
           draggable="true"
           data-player-id="new"
           data-player-name="New Player (${newPlayerDefaults.ml_score})"
           ondragstart="handleNewPlayerDragStart(event)"
           ondragend="handlePlayerDragEnd(event)"
           onclick="assignNewPlayer(this)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm text-green-700">+ New Player</span>
          <span class="text-xs text-green-600">${newPlayerDefaults.ml_score}</span>
        </div>
        <div class="text-xs text-green-600">Add unknown player</div>
      </div>
    `;

    html += filtered.slice(0, 50).map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      const displayName = p.alternativeName ? `${p.nickname} (${p.alternativeName})` : p.nickname;
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${displayName}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${displayName.replace(/'/g, "\\'")}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}${p.alternativeName ? ` <span class="text-gray-400 font-normal">(${p.alternativeName})</span>` : ''}</span>
            <div class="flex items-center gap-1">
              <a href="/players/${p.id}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
              <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
            </div>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.games}g</span>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;

    document.getElementById('player-count').textContent =
      `Showing ${Math.min(filtered.length, 50)} of ${filtered.length} players`;
  }

  function assignPlayer(playerId, element) {
    if (element.classList.contains('already-assigned')) return;

    // Find first empty slot
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        setSelectValue(select, String(playerId));

        // Trigger form submit with tracking
        submitFormWithTracking();

        // Update UI
        setTimeout(() => {
          renderPlayerResults();
          renderRecentPlayers();
          renderObservers();
        }, 100);
        return;
      }
    }

    // No empty slot - add as observer
    addObserver(playerId);
  }

  function assignNewPlayer(element) {
    // Find first empty slot and set it to "new player" mode
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        const slotIndex = slot.dataset.slotIndex;
        setNewPlayerSlot(slotIndex);
        return;
      }
    }
  }

  function setNewPlayerSlot(slotIndex) {
    // Clear the select value (no real player)
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Set the is_new_player hidden field
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '1';
    }

    // Update display to show "New Player" with bottom 5% ELO
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (cell) {
      const existingPlayer = cell.querySelector('.slot-player');
      const existingEmpty = cell.querySelector('.text-gray-400.italic');

      const html = `
        <span class="slot-player cursor-move px-2 py-1 bg-green-50 border border-green-300 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="new"
              data-player-name="New Player (${newPlayerDefaults.ml_score})"
              data-slot-index="${slotIndex}"
              data-is-new="true"
              data-ml-score="${newPlayerDefaults.ml_score}"
              ondragstart="handleSlotDragStart(event, 'new', 'New Player (${newPlayerDefaults.ml_score})', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          <span class="text-green-700">New Player</span>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;

      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    }

    // Set Performance Score, CR, and W/L to new player defaults
    const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
    const crCell = document.getElementById('cr-' + slotIndex);
    const wlCell = document.getElementById('wl-' + slotIndex);
    const facWlCell = document.getElementById('fac-wl-' + slotIndex);

    if (mlScoreCell) mlScoreCell.innerHTML = `<span class="text-red-600 font-medium">${newPlayerDefaults.ml_score}</span>`;
    if (crCell) crCell.textContent = newPlayerDefaults.custom_rating || 1300;
    if (wlCell) wlCell.innerHTML = '<span class="text-gray-400">0/0</span>';
    if (facWlCell) facWlCell.innerHTML = '<span class="text-gray-400">0/0</span>';

    // Mark this slot as a new player for prediction calculations
    const row = cell.closest('tr');
    if (row) row.dataset.isNewPlayer = 'true';

    // Submit the form to save the new player state
    submitFormWithTracking();

    // Update averages and prediction
    updateAverageElos();
    updatePrediction();
  }

  function handleNewPlayerDragStart(e) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: 'new',
      playerName: `New Player (${newPlayerDefaults.ml_score})`,
      sourceType: 'new',
      isNew: true
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function setSelectValue(select, value) {
    select.value = value;

    // Clear is_new_player when assigning a real player
    const slotIndex = select.id.replace('player-select-', '');
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '0';
    }

    // Remove new player marker from row
    const row = select.closest('tr');
    if (row) delete row.dataset.isNewPlayer;

    // Update searchable-select display
    const wrapper = select.previousElementSibling;
    if (wrapper && wrapper.classList.contains('searchable-select')) {
      const input = wrapper.querySelector('.searchable-select-input');
      if (input) {
        const selectedOption = select.options[select.selectedIndex];
        input.value = selectedOption ? selectedOption.text : '';
      }
    }

    // Trigger change and update W/L
    select.dispatchEvent(new Event('change', { bubbles: true }));
    const wlTarget = select.dataset.wlTarget;
    if (wlTarget && typeof updateWL === 'function') {
      updateWL(select, wlTarget);
    }
  }

  function refreshObserverSelect() {
    // No longer needed since we use a hidden select now
    // Kept for compatibility
  }

  function updateWL(select, targetId) {
    const option = select.options[select.selectedIndex];
    const playerId = option.value;
    const factionId = select.dataset.factionId;
    const mlScore = option.dataset.mlScore;
    const wins = option.dataset.wins;
    const losses = option.dataset.losses;
    const wlTarget = document.getElementById(targetId);
    const facWlTarget = document.getElementById(targetId.replace('wl-', 'fac-wl-'));
    const mlScoreTarget = document.getElementById(targetId.replace('wl-', 'ml-score-'));

    // Overall W/L
    if (wins !== undefined && losses !== undefined && wins !== '' && losses !== '') {
      wlTarget.innerHTML = `<span class="text-green-600">${wins}</span>/<span class="text-red-600">${losses}</span>`;
    } else {
      wlTarget.innerHTML = '-';
    }

    // Faction-specific W/L
    if (facWlTarget) {
      if (playerId && factionId) {
        const facWL = getFactionWL(playerId, factionId);
        facWlTarget.innerHTML = `<span class="text-green-600">${facWL.wins}</span>/<span class="text-red-600">${facWL.losses}</span>`;
      } else {
        facWlTarget.innerHTML = '-';
      }
    }

    if (mlScoreTarget && mlScore) {
      const score = parseFloat(mlScore);
      const colorClass = score >= 55 ? 'text-green-600' : (score <= 45 ? 'text-red-600' : 'text-gray-600');
      mlScoreTarget.innerHTML = `<span class="${colorClass} font-medium">${mlScore}</span>`;
    } else if (mlScoreTarget) {
      mlScoreTarget.innerHTML = '-';
    }
    updateAverageElos();
    updatePrediction();
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
  }

  function updateAverageElos() {
    // Recalculate average Performance Score and CR for each team
    [1, 2].forEach(teamNumber => {
      const rows = document.querySelectorAll(`tr.nested-fields[data-team="${teamNumber}"]`);
      let totalMlScore = 0;
      let totalCR = 0;
      let count = 0;
      rows.forEach(row => {
        const select = row.querySelector('select');
        const isNewPlayer = row.dataset.isNewPlayer === 'true';

        if (isNewPlayer) {
          totalMlScore += newPlayerDefaults.ml_score;
          totalCR += newPlayerDefaults.custom_rating || 1300;
          count++;
        } else if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            const mlScore = parseFloat(selectedOption.dataset.mlScore);
            const cr = parseFloat(selectedOption.dataset.customRating) || 1300;
            if (!isNaN(mlScore)) {
              totalMlScore += mlScore;
              totalCR += cr;
              count++;
            }
          }
        }
      });
      const averageMlScore = count > 0 ? (totalMlScore / count).toFixed(1) : 0;
      const averageCR = count > 0 ? Math.round(totalCR / count) : 0;

      // Find the average display for this team's tbody
      const tbody = document.querySelector(`tbody[data-controller="average-elo"]:nth-of-type(${teamNumber})`);
      if (tbody) {
        const mlValueTarget = tbody.querySelector('[data-average-elo-target="mlValue"]');
        if (mlValueTarget) {
          mlValueTarget.textContent = averageMlScore;
        }
        const crValueTarget = tbody.querySelector('[data-average-elo-target="crValue"]');
        if (crValueTarget) {
          crValueTarget.textContent = averageCR;
        }
      }
    });
  }

  // Adaptive weighting constants (matching LobbyWinPredictor service)
  const GAMES_THRESHOLD = 10;
  const NEW_PLAYER_CR_WEIGHT = 40;
  const NEW_PLAYER_ML_WEIGHT = 60;
  const EXPERIENCED_CR_WEIGHT = 70;
  const EXPERIENCED_ML_WEIGHT = 30;
  const CR_MIN = 1200;
  const CR_MAX = 1800;
  const FACTION_GAMES_FOR_FULL_CONFIDENCE = 10;
  const MAX_FACTION_PENALTY_POINTS = 5.0;

  function normalizeCR(cr) {
    return Math.max(0, Math.min(100, ((cr - CR_MIN) / (CR_MAX - CR_MIN)) * 100));
  }

  function getWeightsForGames(games) {
    if (games < GAMES_THRESHOLD) {
      return { crWeight: NEW_PLAYER_CR_WEIGHT, mlWeight: NEW_PLAYER_ML_WEIGHT };
    }
    return { crWeight: EXPERIENCED_CR_WEIGHT, mlWeight: EXPERIENCED_ML_WEIGHT };
  }

  function applyFactionConfidence(score, factionGames) {
    // Calculate confidence: 0 games = 0%, 10 games = ~63%, 20 games = ~86%
    const confidence = 1 - Math.exp(-factionGames / FACTION_GAMES_FOR_FULL_CONFIDENCE);
    // Apply flat penalty for lack of faction experience
    const penalty = (1 - confidence) * MAX_FACTION_PENALTY_POINTS;
    return score - penalty;
  }

  function computePlayerScore(cr, ml, games, factionGames = null) {
    const { crWeight, mlWeight } = getWeightsForGames(games);
    const crNorm = normalizeCR(cr);
    let baseScore = (crNorm * crWeight + ml * mlWeight) / 100.0;

    // Apply faction experience adjustment if provided
    if (factionGames !== null) {
      baseScore = applyFactionConfidence(baseScore, factionGames);
    }

    return baseScore;
  }

  function updatePrediction() {
    const rows = document.querySelectorAll('tr.nested-fields');
    let goodScores = [];
    let evilScores = [];
    let goodCRs = [];
    let evilCRs = [];
    let goodMLs = [];
    let evilMLs = [];

    rows.forEach(row => {
      const team = row.dataset.team;
      if (!team) return;

      const isNewPlayer = row.dataset.isNewPlayer === 'true';
      let mlScore = null;
      let cr = null;
      let games = 0;
      let factionGames = null;
      let playerId = null;
      let factionId = null;

      if (isNewPlayer) {
        mlScore = newPlayerDefaults.ml_score;
        cr = newPlayerDefaults.custom_rating || 1300;
        games = 0;
        factionGames = 0;
      } else {
        const select = row.querySelector('select');
        if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            mlScore = parseFloat(selectedOption.dataset.mlScore);
            cr = parseFloat(selectedOption.dataset.customRating) || 1300;
            games = parseInt(selectedOption.dataset.games) || 0;
            playerId = selectedOption.value;
            factionId = select.dataset.factionId;

            // Get faction-specific games from factionStats
            if (playerId && factionId) {
              const facWL = getFactionWL(playerId, factionId);
              factionGames = facWL.wins + facWL.losses;
            }
          }
        }
      }

      if (mlScore !== null && !isNaN(mlScore)) {
        const combinedScore = computePlayerScore(cr, mlScore, games, factionGames);
        if (team === '1') {
          goodScores.push(combinedScore);
          goodCRs.push(cr);
          goodMLs.push(mlScore);
        } else if (team === '2') {
          evilScores.push(combinedScore);
          evilCRs.push(cr);
          evilMLs.push(mlScore);
        }
      }
    });

    // Calculate combined prediction
    const goodAvgScore = goodScores.length > 0 ? goodScores.reduce((a, b) => a + b, 0) / goodScores.length : 50;
    const evilAvgScore = evilScores.length > 0 ? evilScores.reduce((a, b) => a + b, 0) / evilScores.length : 50;

    // Convert score difference to win probability
    const scoreDiff = goodAvgScore - evilAvgScore;
    const goodExpected = 1 / (1 + Math.exp(-scoreDiff / 5.0));
    const goodPct = Math.round(goodExpected * 100);
    const evilPct = 100 - goodPct;

    // Calculate averages for display
    const goodCRAvg = goodCRs.length > 0 ? goodCRs.reduce((a, b) => a + b, 0) / goodCRs.length : 1300;
    const evilCRAvg = evilCRs.length > 0 ? evilCRs.reduce((a, b) => a + b, 0) / evilCRs.length : 1300;
    const goodMLAvg = goodMLs.length > 0 ? goodMLs.reduce((a, b) => a + b, 0) / goodMLs.length : 50;
    const evilMLAvg = evilMLs.length > 0 ? evilMLs.reduce((a, b) => a + b, 0) / evilMLs.length : 50;

    // Update combined prediction bar
    const combinedBar = document.getElementById('combined-win-bar');
    const combinedGoodPct = document.getElementById('combined-good-pct');
    const combinedEvilPct = document.getElementById('combined-evil-pct');

    if (combinedBar) combinedBar.style.width = goodPct + '%';
    if (combinedGoodPct) combinedGoodPct.textContent = goodPct + '%';
    if (combinedEvilPct) combinedEvilPct.textContent = evilPct + '%';

    // Update detail display
    const predGoodCR = document.getElementById('pred-good-cr');
    const predEvilCR = document.getElementById('pred-evil-cr');
    const predGoodML = document.getElementById('pred-good-ml');
    const predEvilML = document.getElementById('pred-evil-ml');

    if (predGoodCR) predGoodCR.textContent = Math.round(goodCRAvg);
    if (predEvilCR) predEvilCR.textContent = Math.round(evilCRAvg);
    if (predGoodML) predGoodML.textContent = goodMLAvg.toFixed(1);
    if (predEvilML) predEvilML.textContent = evilMLAvg.toFixed(1);
  }

  // Drag handlers
  function handlePlayerDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'search'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function handleObserverDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'observer'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight only player slots (not observer zone since they're already observers)
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function handleSlotDragStart(e, playerId, playerName, slotIndex) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'slot',
      sourceIndex: slotIndex
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight all drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function clearSlot(slotIndex) {
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));

      // Clear the is_new_player hidden field
      const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
      if (isNewPlayerField) {
        isNewPlayerField.value = '0';
      }

      // Update the cell display
      updateSlotDisplay(slotIndex, null, null);

      // Remove new player marker if present
      const cell = document.getElementById('player-cell-' + slotIndex);
      const row = cell?.closest('tr');
      if (row) delete row.dataset.isNewPlayer;

      // Trigger form submit with tracking
      submitFormWithTracking();

      // Update all lists
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
        updateAverageElos();
        updatePrediction();
      }, 100);
    }
  }

  function updateSlotDisplay(slotIndex, playerId, playerName) {
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (!cell) return;

    // Find existing slot-player span or empty slot text
    const existingPlayer = cell.querySelector('.slot-player');
    const existingEmpty = cell.querySelector('.text-gray-400.italic');

    if (playerId && playerName) {
      const html = `
        <span class="slot-player cursor-move px-4 py-2 bg-blue-50 border border-blue-200 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="${playerId}"
              data-player-name="${playerName}"
              data-slot-index="${slotIndex}"
              ondragstart="handleSlotDragStart(event, ${playerId}, '${playerName}', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          ${playerName}
          <a href="/players/${playerId}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
            </svg>
          </a>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    } else {
      const html = '<span class="text-gray-400 italic">Empty slot</span>';
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      }
    }

    // Update Performance Score, CR, and W/L display
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      const option = select.options[select.selectedIndex];
      const playerId = option ? option.value : null;
      const factionId = select.dataset.factionId;
      const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
      const crCell = document.getElementById('cr-' + slotIndex);
      const wlCell = document.getElementById('wl-' + slotIndex);
      const facWlCell = document.getElementById('fac-wl-' + slotIndex);

      if (mlScoreCell) {
        if (option && option.dataset.mlScore) {
          const score = parseFloat(option.dataset.mlScore);
          const colorClass = score >= 55 ? 'text-green-600' : (score <= 45 ? 'text-red-600' : 'text-gray-600');
          mlScoreCell.innerHTML = `<span class="${colorClass} font-medium">${option.dataset.mlScore}</span>`;
        } else {
          mlScoreCell.textContent = '-';
        }
      }
      // Custom Rating
      if (crCell) {
        if (option && option.dataset.customRating) {
          crCell.textContent = option.dataset.customRating;
        } else {
          crCell.textContent = '-';
        }
      }
      // Overall W/L
      if (wlCell) {
        if (option && option.dataset.wins !== undefined && option.dataset.losses !== undefined) {
          wlCell.innerHTML = `<span class="text-green-600">${option.dataset.wins}</span>/<span class="text-red-600">${option.dataset.losses}</span>`;
        } else {
          wlCell.textContent = '-';
        }
      }
      // Faction W/L
      if (facWlCell) {
        if (playerId && factionId) {
          const facWL = getFactionWL(playerId, factionId);
          facWlCell.innerHTML = `<span class="text-green-600">${facWL.wins}</span>/<span class="text-red-600">${facWL.losses}</span>`;
        } else {
          facWlCell.textContent = '-';
        }
      }
    }
  }

  function handlePlayerDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.remove('drop-zone-active', 'drop-zone-hover');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.remove('drop-zone-active', 'drop-zone-hover');
  }

  // Expose functions to window for Stimulus controller
  window.setSelectValue = setSelectValue;
  window.refreshObserverSelect = refreshObserverSelect;
  window.renderPlayerResults = renderPlayerResults;
  window.renderRecentPlayers = renderRecentPlayers;
  window.renderObservers = renderObservers;
  window.addObserver = addObserver;
  window.removeObserver = removeObserver;
  window.clearSlot = clearSlot;
  window.updateSlotDisplay = updateSlotDisplay;
  window.updateAverageElos = updateAverageElos;
  window.updatePrediction = updatePrediction;
  window.handlePlayerDragStart = handlePlayerDragStart;
  window.handleObserverDragStart = handleObserverDragStart;
  window.handleSlotDragStart = handleSlotDragStart;
  window.handlePlayerDragEnd = handlePlayerDragEnd;
  window.handleNewPlayerDragStart = handleNewPlayerDragStart;
  window.assignNewPlayer = assignNewPlayer;
  window.setNewPlayerSlot = setNewPlayerSlot;

  // Track pending form submissions
  let pendingSavePromise = null;
  let pendingSaveResolve = null;

  function showSaveStatus(show) {
    const status = document.getElementById('save-status');
    if (status) {
      status.classList.toggle('hidden', !show);
    }
  }

  // Submit form and track the save
  function submitFormWithTracking() {
    const form = document.querySelector('form');
    if (!form) return;

    showSaveStatus(true);

    // Create promise if not already pending
    if (!pendingSavePromise) {
      pendingSavePromise = new Promise((resolve) => {
        pendingSaveResolve = resolve;
      });
    }

    form.requestSubmit();
  }

  // Listen for form submission completion
  document.addEventListener('turbo:submit-end', () => {
    showSaveStatus(false);
    if (pendingSaveResolve) {
      // Small delay to ensure server has fully processed
      setTimeout(() => {
        pendingSaveResolve();
        pendingSavePromise = null;
        pendingSaveResolve = null;
      }, 100);
    }
  });

  // Wait for any pending saves
  async function waitForPendingSaves() {
    if (pendingSavePromise) {
      await pendingSavePromise;
    }
    // Extra small delay to be safe
    await new Promise(r => setTimeout(r, 150));
  }

  // Balance lobby function
  async function balanceLobby() {
    const btn = document.getElementById('balance-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Saving...';

    try {
      // Wait for any pending form submissions
      await waitForPendingSaves();

      btn.innerHTML = '‚è≥ Balancing...';

      const response = await fetch('<%= balance_lobby_path(@lobby) %>', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      });

      const result = await response.json();

      if (result.success) {
        if (result.swaps_count > 0) {
          // Reload the page to show updated lobby
          window.location.reload();
        } else {
          btn.innerHTML = '‚úì Already balanced';
          setTimeout(() => { btn.innerHTML = originalText; btn.disabled = false; }, 2000);
        }
      } else {
        alert('Balance failed: ' + result.message);
        btn.innerHTML = originalText;
        btn.disabled = false;
      }
    } catch (error) {
      alert('Balance failed: ' + error.message);
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }
  window.balanceLobby = balanceLobby;

  // Reset lobby - clear all player slots
  async function resetLobby() {
    if (!confirm('Clear all players from this lobby?')) return;

    const btn = document.getElementById('reset-btn');
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Resetting...';

    try {
      // Clear all player selects
      document.querySelectorAll('select[name*="player_id"]').forEach(select => {
        select.value = '';
      });

      // Clear all is_new_player hidden fields
      document.querySelectorAll('input[name*="is_new_player"]').forEach(input => {
        input.value = '0';
      });

      // Clear observers
      const observerSelect = document.getElementById('observer-select');
      if (observerSelect) {
        Array.from(observerSelect.options).forEach(opt => opt.selected = false);
      }

      // Submit the form and wait for it to complete
      submitFormWithTracking();
      await waitForPendingSaves();

      // Reload to get fresh state
      window.location.reload();
    } catch (error) {
      alert('Reset failed: ' + error.message);
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }
  window.resetLobby = resetLobby;

  // Event listeners
  document.getElementById('player-search-input').addEventListener('input', renderPlayerResults);

  // Also update when selects change
  document.addEventListener('change', (e) => {
    if (e.target.matches('select[name*="player_id"]') || e.target.id === 'observer-select') {
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 50);
    }
  });

  document.addEventListener('DOMContentLoaded', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
  });
  document.addEventListener('turbo:load', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
  });
</script>
