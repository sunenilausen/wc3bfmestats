<% content_for :title, "Editing lobby" %>

<div class="flex gap-6" data-controller="lobby-drag">
  <div class="flex-1">
    <div class="flex items-center gap-4 mb-1">
      <h1 class="font-bold text-2xl">Editing lobby</h1>
      <%= link_to "View", @lobby, class: "text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded" %>
    </div>

    <%= render partial: "lobby", locals: { lobby: @lobby, editable: true } %>
  </div>

  <div class="w-56 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Player Search</h2>

      <div class="mb-3">
        <input type="text"
               id="player-search-input"
               placeholder="Search by name..."
               class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      </div>

      <div id="player-search-results" class="space-y-1 h-[728px] overflow-y-auto">
        <!-- Results populated by JS -->
      </div>

      <p id="player-count" class="text-xs text-gray-400 mt-2"></p>
    </div>
  </div>

  <div class="w-80 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">28 Recent Players</h2>

      <div id="recent-players-list" class="grid grid-cols-2 gap-1 h-[780px]">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <div class="w-40 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Observers</h2>
      <p class="text-xs text-gray-500 mb-2">Click to remove</p>

      <div id="observers-list" class="space-y-1 max-h-[70vh] overflow-y-auto"
           data-lobby-drag-target="observerZone">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<script id="players-data" type="application/json">
  <%= raw @players_search_data.to_json %>
</script>

<script id="recent-players-data" type="application/json">
  <%= raw @recent_players.to_json %>
</script>

<script id="new-player-defaults" type="application/json">
  <%= raw @new_player_defaults.to_json %>
</script>

<script id="faction-stats-data" type="application/json">
  <%= raw @faction_stats.transform_keys { |k| "#{k[0]}_#{k[1]}" }.to_json %>
</script>

<style>
  .drop-zone-active {
    outline: 2px dashed #cbd5e1;
    outline-offset: -2px;
  }
  .drop-zone-hover {
    background-color: #dbeafe !important;
    outline-color: #3b82f6 !important;
  }
  .dragging {
    opacity: 0.5;
  }
  .already-assigned {
    opacity: 0.4;
    background-color: #f3f4f6 !important;
    cursor: default;
  }
  .player-card {
    cursor: pointer;
  }
  .player-card:not(.already-assigned):hover {
    background-color: #dbeafe;
    border-color: #3b82f6;
  }
</style>

<script>
  const allPlayers = JSON.parse(document.getElementById('players-data').textContent);
  const recentPlayers = JSON.parse(document.getElementById('recent-players-data').textContent);
  const newPlayerDefaults = JSON.parse(document.getElementById('new-player-defaults').textContent);
  const factionStats = JSON.parse(document.getElementById('faction-stats-data').textContent);

  // Helper to get faction W/L for a player
  function getFactionWL(playerId, factionId) {
    const key = `${playerId}_${factionId}`;
    return factionStats[key] || { wins: 0, losses: 0 };
  }

  // Special "New Player" option with default ratings
  const NEW_PLAYER = { id: 'new', nickname: `New Player (${newPlayerDefaults.ml_score})`, customRating: newPlayerDefaults.custom_rating, mlScore: newPlayerDefaults.ml_score, wins: 0, losses: 0, games: 0, isNew: true };

  function getAssignedPlayerIds() {
    const assignedIds = new Set();
    document.querySelectorAll('select[name*="player_id"]').forEach(select => {
      if (select.value) assignedIds.add(select.value);
    });
    const observerSelect = document.getElementById('observer-select');
    if (observerSelect) {
      Array.from(observerSelect.selectedOptions).forEach(opt => {
        assignedIds.add(opt.value);
      });
    }
    return assignedIds;
  }

  function renderRecentPlayers() {
    const assignedIds = getAssignedPlayerIds();
    const container = document.getElementById('recent-players-list');

    container.innerHTML = recentPlayers.map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${p.nickname}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${p.nickname}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}</span>
            <div class="flex items-center gap-1">
              <a href="/players/${p.id}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
              <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
            </div>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.lastSeen || ''}</span>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderObservers() {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const container = document.getElementById('observers-list');
    const selectedObservers = Array.from(observerSelect.selectedOptions).map(opt => {
      const playerData = allPlayers.find(p => String(p.id) === opt.value);
      return {
        id: opt.value,
        nickname: opt.text,
        mlScore: playerData ? playerData.mlScore : null,
        wins: playerData ? playerData.wins : 0,
        losses: playerData ? playerData.losses : 0
      };
    });

    container.innerHTML = selectedObservers.map(p => {
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
      <div class="player-card p-2 bg-yellow-50 border border-yellow-200 rounded transition-colors cursor-move"
           draggable="true"
           data-player-id="${p.id}"
           data-player-name="${p.nickname}"
           data-source-type="observer"
           ondragstart="handleObserverDragStart(event, ${p.id}, '${p.nickname}')"
           ondragend="handlePlayerDragEnd(event)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm">${p.nickname}</span>
          <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
        </div>
        <div class="flex justify-between items-center text-xs text-gray-500">
          <span>
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
          </span>
          <button type="button" onclick="removeObserver(${p.id})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </div>
      </div>
    `}).join('');

    if (selectedObservers.length === 0) {
      container.innerHTML = '<div class="p-4 border-2 border-dashed border-gray-300 rounded text-center text-xs text-gray-400 italic">Drag players here</div>';
    }
  }

  function removeObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && option.selected) {
      option.selected = false;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      const form = document.querySelector('form');
      if (form) form.requestSubmit();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function addObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && !option.selected) {
      option.selected = true;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      const form = document.querySelector('form');
      if (form) form.requestSubmit();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function renderPlayerResults() {
    const searchTerm = document.getElementById('player-search-input').value.toLowerCase();
    const assignedIds = getAssignedPlayerIds();

    const filtered = allPlayers.filter(p => {
      if (searchTerm && !p.nickname.toLowerCase().includes(searchTerm)) return false;
      return true;
    });

    const container = document.getElementById('player-search-results');

    // Add "New Player" card at the top
    let html = `
      <div class="player-card p-2 bg-green-50 border border-green-300 rounded transition-colors cursor-pointer hover:bg-green-100"
           draggable="true"
           data-player-id="new"
           data-player-name="New Player (${newPlayerDefaults.ml_score})"
           ondragstart="handleNewPlayerDragStart(event)"
           ondragend="handlePlayerDragEnd(event)"
           onclick="assignNewPlayer(this)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm text-green-700">+ New Player</span>
          <span class="text-xs text-green-600">${newPlayerDefaults.ml_score}</span>
        </div>
        <div class="text-xs text-green-600">Add unknown player</div>
      </div>
    `;

    html += filtered.slice(0, 50).map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${p.nickname}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${p.nickname}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}</span>
            <div class="flex items-center gap-1">
              <a href="/players/${p.id}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
              </a>
              <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
            </div>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.games}g</span>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;

    document.getElementById('player-count').textContent =
      `Showing ${Math.min(filtered.length, 50)} of ${filtered.length} players`;
  }

  function assignPlayer(playerId, element) {
    if (element.classList.contains('already-assigned')) return;

    // Find first empty slot
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        setSelectValue(select, String(playerId));

        // Trigger form submit
        const form = document.querySelector('form');
        if (form) form.requestSubmit();

        // Update UI
        setTimeout(() => {
          renderPlayerResults();
          renderRecentPlayers();
          renderObservers();
        }, 100);
        return;
      }
    }

    // No empty slot - add as observer
    addObserver(playerId);
  }

  function assignNewPlayer(element) {
    // Find first empty slot and set it to "new player" mode
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        const slotIndex = slot.dataset.slotIndex;
        setNewPlayerSlot(slotIndex);
        return;
      }
    }
  }

  function setNewPlayerSlot(slotIndex) {
    // Clear the select value (no real player)
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Set the is_new_player hidden field
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '1';
    }

    // Update display to show "New Player" with bottom 5% ELO
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (cell) {
      const existingPlayer = cell.querySelector('.slot-player');
      const existingEmpty = cell.querySelector('.text-gray-400.italic');

      const html = `
        <span class="slot-player cursor-move px-2 py-1 bg-green-50 border border-green-300 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="new"
              data-player-name="New Player (${newPlayerDefaults.ml_score})"
              data-slot-index="${slotIndex}"
              data-is-new="true"
              data-ml-score="${newPlayerDefaults.ml_score}"
              ondragstart="handleSlotDragStart(event, 'new', 'New Player (${newPlayerDefaults.ml_score})', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          <span class="text-green-700">New Player</span>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;

      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    }

    // Set Performance Score, CR, and W/L to new player defaults
    const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
    const crCell = document.getElementById('cr-' + slotIndex);
    const wlCell = document.getElementById('wl-' + slotIndex);
    const facWlCell = document.getElementById('fac-wl-' + slotIndex);

    if (mlScoreCell) mlScoreCell.innerHTML = `<span class="text-red-600 font-medium">${newPlayerDefaults.ml_score}</span>`;
    if (crCell) crCell.textContent = newPlayerDefaults.custom_rating || 1300;
    if (wlCell) wlCell.innerHTML = '<span class="text-gray-400">0/0</span>';
    if (facWlCell) facWlCell.innerHTML = '<span class="text-gray-400">0/0</span>';

    // Mark this slot as a new player for prediction calculations
    const row = cell.closest('tr');
    if (row) row.dataset.isNewPlayer = 'true';

    // Submit the form to save the new player state
    const form = document.querySelector('form');
    if (form) form.requestSubmit();

    // Update averages and prediction
    updateAverageElos();
    updatePrediction();
  }

  function handleNewPlayerDragStart(e) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: 'new',
      playerName: `New Player (${newPlayerDefaults.ml_score})`,
      sourceType: 'new',
      isNew: true
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function setSelectValue(select, value) {
    select.value = value;

    // Clear is_new_player when assigning a real player
    const slotIndex = select.id.replace('player-select-', '');
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '0';
    }

    // Remove new player marker from row
    const row = select.closest('tr');
    if (row) delete row.dataset.isNewPlayer;

    // Update searchable-select display
    const wrapper = select.previousElementSibling;
    if (wrapper && wrapper.classList.contains('searchable-select')) {
      const input = wrapper.querySelector('.searchable-select-input');
      if (input) {
        const selectedOption = select.options[select.selectedIndex];
        input.value = selectedOption ? selectedOption.text : '';
      }
    }

    // Trigger change and update W/L
    select.dispatchEvent(new Event('change', { bubbles: true }));
    const wlTarget = select.dataset.wlTarget;
    if (wlTarget && typeof updateWL === 'function') {
      updateWL(select, wlTarget);
    }
  }

  function refreshObserverSelect() {
    // No longer needed since we use a hidden select now
    // Kept for compatibility
  }

  function updateWL(select, targetId) {
    const option = select.options[select.selectedIndex];
    const playerId = option.value;
    const factionId = select.dataset.factionId;
    const mlScore = option.dataset.mlScore;
    const wins = option.dataset.wins;
    const losses = option.dataset.losses;
    const wlTarget = document.getElementById(targetId);
    const facWlTarget = document.getElementById(targetId.replace('wl-', 'fac-wl-'));
    const mlScoreTarget = document.getElementById(targetId.replace('wl-', 'ml-score-'));

    // Overall W/L
    if (wins !== undefined && losses !== undefined && wins !== '' && losses !== '') {
      wlTarget.innerHTML = `<span class="text-green-600">${wins}</span>/<span class="text-red-600">${losses}</span>`;
    } else {
      wlTarget.innerHTML = '-';
    }

    // Faction-specific W/L
    if (facWlTarget) {
      if (playerId && factionId) {
        const facWL = getFactionWL(playerId, factionId);
        facWlTarget.innerHTML = `<span class="text-green-600">${facWL.wins}</span>/<span class="text-red-600">${facWL.losses}</span>`;
      } else {
        facWlTarget.innerHTML = '-';
      }
    }

    if (mlScoreTarget && mlScore) {
      const score = parseFloat(mlScore);
      const colorClass = score >= 55 ? 'text-green-600' : (score <= 45 ? 'text-red-600' : 'text-gray-600');
      mlScoreTarget.innerHTML = `<span class="${colorClass} font-medium">${mlScore}</span>`;
    } else if (mlScoreTarget) {
      mlScoreTarget.innerHTML = '-';
    }
    updateAverageElos();
    updatePrediction();
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
  }

  function updateAverageElos() {
    // Recalculate average Performance Score and CR for each team
    [1, 2].forEach(teamNumber => {
      const rows = document.querySelectorAll(`tr.nested-fields[data-team="${teamNumber}"]`);
      let totalMlScore = 0;
      let totalCR = 0;
      let count = 0;
      rows.forEach(row => {
        const select = row.querySelector('select');
        const isNewPlayer = row.dataset.isNewPlayer === 'true';

        if (isNewPlayer) {
          totalMlScore += newPlayerDefaults.ml_score;
          totalCR += newPlayerDefaults.custom_rating || 1300;
          count++;
        } else if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            const mlScore = parseFloat(selectedOption.dataset.mlScore);
            const cr = parseFloat(selectedOption.dataset.customRating) || 1300;
            if (!isNaN(mlScore)) {
              totalMlScore += mlScore;
              totalCR += cr;
              count++;
            }
          }
        }
      });
      const averageMlScore = count > 0 ? (totalMlScore / count).toFixed(1) : 0;
      const averageCR = count > 0 ? Math.round(totalCR / count) : 0;

      // Find the average display for this team's tbody
      const tbody = document.querySelector(`tbody[data-controller="average-elo"]:nth-of-type(${teamNumber})`);
      if (tbody) {
        const mlValueTarget = tbody.querySelector('[data-average-elo-target="mlValue"]');
        if (mlValueTarget) {
          mlValueTarget.textContent = averageMlScore;
        }
        const crValueTarget = tbody.querySelector('[data-average-elo-target="crValue"]');
        if (crValueTarget) {
          crValueTarget.textContent = averageCR;
        }
      }
    });
  }

  function updatePrediction() {
    const rows = document.querySelectorAll('tr.nested-fields');
    let goodScores = [];
    let evilScores = [];
    let goodCRs = [];
    let evilCRs = [];

    rows.forEach(row => {
      const team = row.dataset.team;
      if (!team) return;

      const isNewPlayer = row.dataset.isNewPlayer === 'true';
      let mlScore = null;
      let cr = null;

      if (isNewPlayer) {
        mlScore = newPlayerDefaults.ml_score;
        cr = newPlayerDefaults.custom_rating || 1300;
      } else {
        const select = row.querySelector('select');
        if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            mlScore = parseFloat(selectedOption.dataset.mlScore);
            cr = parseFloat(selectedOption.dataset.customRating) || 1300;
          }
        }
      }

      if (mlScore !== null && !isNaN(mlScore)) {
        if (team === '1') {
          goodScores.push(mlScore);
          goodCRs.push(cr);
        } else if (team === '2') {
          evilScores.push(mlScore);
          evilCRs.push(cr);
        }
      }
    });

    // Calculate performance score prediction
    const goodAvg = goodScores.length > 0 ? goodScores.reduce((a, b) => a + b, 0) / goodScores.length : 50;
    const evilAvg = evilScores.length > 0 ? evilScores.reduce((a, b) => a + b, 0) / evilScores.length : 50;

    // Use logistic function to convert score difference to win probability
    const scoreDiff = goodAvg - evilAvg;
    const goodExpected = 1 / (1 + Math.exp(-scoreDiff / 15));
    const goodPct = Math.round(goodExpected * 100);
    const evilPct = 100 - goodPct;

    const goodBar = document.getElementById('good-win-bar');
    const goodPctEl = document.getElementById('good-win-pct');
    const evilPctEl = document.getElementById('evil-win-pct');
    const mlGoodAvgEl = document.getElementById('ml-good-avg');
    const mlEvilAvgEl = document.getElementById('ml-evil-avg');

    if (goodBar) goodBar.style.width = goodPct + '%';
    if (goodPctEl) goodPctEl.textContent = goodPct + '%';
    if (evilPctEl) evilPctEl.textContent = evilPct + '%';
    if (mlGoodAvgEl) mlGoodAvgEl.textContent = goodAvg.toFixed(1);
    if (mlEvilAvgEl) mlEvilAvgEl.textContent = evilAvg.toFixed(1);

    // Calculate CR prediction using ELO formula
    const goodCRAvg = goodCRs.length > 0 ? goodCRs.reduce((a, b) => a + b, 0) / goodCRs.length : 1300;
    const evilCRAvg = evilCRs.length > 0 ? evilCRs.reduce((a, b) => a + b, 0) / evilCRs.length : 1300;

    const crGoodExpected = 1 / (1 + Math.pow(10, (evilCRAvg - goodCRAvg) / 400));
    const crGoodPct = Math.round(crGoodExpected * 100);
    const crEvilPct = 100 - crGoodPct;

    const crGoodBar = document.getElementById('cr-good-win-bar');
    const crGoodPctEl = document.getElementById('cr-good-win-pct');
    const crEvilPctEl = document.getElementById('cr-evil-win-pct');
    const crGoodAvgEl = document.getElementById('cr-good-avg');
    const crEvilAvgEl = document.getElementById('cr-evil-avg');

    if (crGoodBar) crGoodBar.style.width = crGoodPct + '%';
    if (crGoodPctEl) crGoodPctEl.textContent = crGoodPct + '%';
    if (crEvilPctEl) crEvilPctEl.textContent = crEvilPct + '%';
    if (crGoodAvgEl) crGoodAvgEl.textContent = Math.round(goodCRAvg);
    if (crEvilAvgEl) crEvilAvgEl.textContent = Math.round(evilCRAvg);
  }

  // Drag handlers
  function handlePlayerDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'search'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function handleObserverDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'observer'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight only player slots (not observer zone since they're already observers)
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function handleSlotDragStart(e, playerId, playerName, slotIndex) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'slot',
      sourceIndex: slotIndex
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight all drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function clearSlot(slotIndex) {
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));

      // Clear the is_new_player hidden field
      const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
      if (isNewPlayerField) {
        isNewPlayerField.value = '0';
      }

      // Update the cell display
      updateSlotDisplay(slotIndex, null, null);

      // Remove new player marker if present
      const cell = document.getElementById('player-cell-' + slotIndex);
      const row = cell?.closest('tr');
      if (row) delete row.dataset.isNewPlayer;

      // Trigger form submit
      const form = document.querySelector('form');
      if (form) form.requestSubmit();

      // Update all lists
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
        updateAverageElos();
        updatePrediction();
      }, 100);
    }
  }

  function updateSlotDisplay(slotIndex, playerId, playerName) {
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (!cell) return;

    // Find existing slot-player span or empty slot text
    const existingPlayer = cell.querySelector('.slot-player');
    const existingEmpty = cell.querySelector('.text-gray-400.italic');

    if (playerId && playerName) {
      const html = `
        <span class="slot-player cursor-move px-4 py-2 bg-blue-50 border border-blue-200 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="${playerId}"
              data-player-name="${playerName}"
              data-slot-index="${slotIndex}"
              ondragstart="handleSlotDragStart(event, ${playerId}, '${playerName}', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          ${playerName}
          <a href="/players/${playerId}" class="text-gray-400 hover:text-blue-600" title="View player" onclick="event.stopPropagation()">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
            </svg>
          </a>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    } else {
      const html = '<span class="text-gray-400 italic">Empty slot</span>';
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      }
    }

    // Update Performance Score, CR, and W/L display
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      const option = select.options[select.selectedIndex];
      const playerId = option ? option.value : null;
      const factionId = select.dataset.factionId;
      const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
      const crCell = document.getElementById('cr-' + slotIndex);
      const wlCell = document.getElementById('wl-' + slotIndex);
      const facWlCell = document.getElementById('fac-wl-' + slotIndex);

      if (mlScoreCell) {
        if (option && option.dataset.mlScore) {
          const score = parseFloat(option.dataset.mlScore);
          const colorClass = score >= 55 ? 'text-green-600' : (score <= 45 ? 'text-red-600' : 'text-gray-600');
          mlScoreCell.innerHTML = `<span class="${colorClass} font-medium">${option.dataset.mlScore}</span>`;
        } else {
          mlScoreCell.textContent = '-';
        }
      }
      // Custom Rating
      if (crCell) {
        if (option && option.dataset.customRating) {
          crCell.textContent = option.dataset.customRating;
        } else {
          crCell.textContent = '-';
        }
      }
      // Overall W/L
      if (wlCell) {
        if (option && option.dataset.wins !== undefined && option.dataset.losses !== undefined) {
          wlCell.innerHTML = `<span class="text-green-600">${option.dataset.wins}</span>/<span class="text-red-600">${option.dataset.losses}</span>`;
        } else {
          wlCell.textContent = '-';
        }
      }
      // Faction W/L
      if (facWlCell) {
        if (playerId && factionId) {
          const facWL = getFactionWL(playerId, factionId);
          facWlCell.innerHTML = `<span class="text-green-600">${facWL.wins}</span>/<span class="text-red-600">${facWL.losses}</span>`;
        } else {
          facWlCell.textContent = '-';
        }
      }
    }
  }

  function handlePlayerDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.remove('drop-zone-active', 'drop-zone-hover');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.remove('drop-zone-active', 'drop-zone-hover');
  }

  // Expose functions to window for Stimulus controller
  window.setSelectValue = setSelectValue;
  window.refreshObserverSelect = refreshObserverSelect;
  window.renderPlayerResults = renderPlayerResults;
  window.renderRecentPlayers = renderRecentPlayers;
  window.renderObservers = renderObservers;
  window.addObserver = addObserver;
  window.removeObserver = removeObserver;
  window.clearSlot = clearSlot;
  window.updateSlotDisplay = updateSlotDisplay;
  window.updateAverageElos = updateAverageElos;
  window.updatePrediction = updatePrediction;
  window.handlePlayerDragStart = handlePlayerDragStart;
  window.handleObserverDragStart = handleObserverDragStart;
  window.handleSlotDragStart = handleSlotDragStart;
  window.handlePlayerDragEnd = handlePlayerDragEnd;
  window.handleNewPlayerDragStart = handleNewPlayerDragStart;
  window.assignNewPlayer = assignNewPlayer;
  window.setNewPlayerSlot = setNewPlayerSlot;

  // Event listeners
  document.getElementById('player-search-input').addEventListener('input', renderPlayerResults);

  // Also update when selects change
  document.addEventListener('change', (e) => {
    if (e.target.matches('select[name*="player_id"]') || e.target.id === 'observer-select') {
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 50);
    }
  });

  document.addEventListener('DOMContentLoaded', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
  });
  document.addEventListener('turbo:load', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
  });
</script>
