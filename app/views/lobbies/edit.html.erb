<% content_for :title, "Editing lobby" %>

<div class="flex gap-6" data-controller="lobby-drag">
  <div class="flex-1">
    <div class="flex items-center gap-4 mb-4">
      <h1 class="font-bold text-2xl">Editing lobby</h1>
      <%= link_to "View", @lobby, class: "text-sm px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded" %>
    </div>

    <%= render partial: "lobby", locals: { lobby: @lobby, editable: true } %>
  </div>

  <div class="w-56 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Player Search</h2>

      <div class="mb-3">
        <input type="text"
               id="player-search-input"
               placeholder="Search by name..."
               class="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
      </div>

      <div id="player-search-results" class="space-y-1 max-h-[60vh] overflow-y-auto">
        <!-- Results populated by JS -->
      </div>

      <p id="player-count" class="text-xs text-gray-400 mt-2"></p>
    </div>
  </div>

  <div class="w-48 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Recent Players</h2>
      <p class="text-xs text-gray-500 mb-2">50 most recent</p>

      <div id="recent-players-list" class="space-y-1 max-h-[70vh] overflow-y-auto">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>

  <div class="w-40 flex-shrink-0">
    <div class="sticky top-4">
      <h2 class="font-bold text-lg mb-3">Observers</h2>
      <p class="text-xs text-gray-500 mb-2">Click to remove</p>

      <div id="observers-list" class="space-y-1 max-h-[70vh] overflow-y-auto"
           data-lobby-drag-target="observerZone">
        <!-- Populated by JS -->
      </div>
    </div>
  </div>
</div>

<script id="players-data" type="application/json">
  <%= raw @players_search_data.to_json %>
</script>

<script id="recent-players-data" type="application/json">
  <%= raw @recent_players.to_json %>
</script>

<script id="new-player-defaults" type="application/json">
  <%= raw @new_player_defaults.to_json %>
</script>

<style>
  .drop-zone-active {
    outline: 2px dashed #cbd5e1;
    outline-offset: -2px;
  }
  .drop-zone-hover {
    background-color: #dbeafe !important;
    outline-color: #3b82f6 !important;
  }
  .dragging {
    opacity: 0.5;
  }
  .already-assigned {
    opacity: 0.4;
    background-color: #f3f4f6 !important;
    cursor: default;
  }
  .player-card {
    cursor: pointer;
  }
  .player-card:not(.already-assigned):hover {
    background-color: #dbeafe;
    border-color: #3b82f6;
  }
</style>

<script>
  const allPlayers = JSON.parse(document.getElementById('players-data').textContent);
  const recentPlayers = JSON.parse(document.getElementById('recent-players-data').textContent);
  const newPlayerDefaults = JSON.parse(document.getElementById('new-player-defaults').textContent);

  // Special "New Player" option with bottom 5% ratings
  const NEW_PLAYER = { id: 'new', nickname: `New Player (${newPlayerDefaults.ml_score})`, elo: newPlayerDefaults.elo, glicko: newPlayerDefaults.glicko, mlScore: newPlayerDefaults.ml_score, wins: 0, losses: 0, games: 0, isNew: true };

  function getAssignedPlayerIds() {
    const assignedIds = new Set();
    document.querySelectorAll('select[name*="player_id"]').forEach(select => {
      if (select.value) assignedIds.add(select.value);
    });
    const observerSelect = document.getElementById('observer-select');
    if (observerSelect) {
      Array.from(observerSelect.selectedOptions).forEach(opt => {
        assignedIds.add(opt.value);
      });
    }
    return assignedIds;
  }

  function renderRecentPlayers() {
    const assignedIds = getAssignedPlayerIds();
    const container = document.getElementById('recent-players-list');

    container.innerHTML = recentPlayers.map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${p.nickname}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${p.nickname}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}</span>
            <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.lastSeen || ''}</span>
          </div>
        </div>
      `;
    }).join('');
  }

  function renderObservers() {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const container = document.getElementById('observers-list');
    const selectedObservers = Array.from(observerSelect.selectedOptions).map(opt => {
      const playerData = allPlayers.find(p => String(p.id) === opt.value);
      return {
        id: opt.value,
        nickname: opt.text,
        mlScore: playerData ? playerData.mlScore : null,
        wins: playerData ? playerData.wins : 0,
        losses: playerData ? playerData.losses : 0
      };
    });

    container.innerHTML = selectedObservers.map(p => {
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
      <div class="player-card p-2 bg-yellow-50 border border-yellow-200 rounded transition-colors cursor-move"
           draggable="true"
           data-player-id="${p.id}"
           data-player-name="${p.nickname}"
           data-source-type="observer"
           ondragstart="handleObserverDragStart(event, ${p.id}, '${p.nickname}')"
           ondragend="handlePlayerDragEnd(event)">
        <div class="flex justify-between items-start">
          <div>
            <div class="font-medium text-sm">${p.nickname}</div>
            <div class="text-xs text-gray-500">
              <span class="${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
              <span class="ml-1">
                <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
              </span>
            </div>
          </div>
          <button type="button" onclick="removeObserver(${p.id})" class="text-gray-400 hover:text-red-500 text-lg leading-none">&times;</button>
        </div>
      </div>
    `}).join('');

    if (selectedObservers.length === 0) {
      container.innerHTML = '<div class="p-4 border-2 border-dashed border-gray-300 rounded text-center text-xs text-gray-400 italic">Drag players here</div>';
    }
  }

  function removeObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && option.selected) {
      option.selected = false;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      const form = document.querySelector('form');
      if (form) form.requestSubmit();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function addObserver(playerId) {
    const observerSelect = document.getElementById('observer-select');
    if (!observerSelect) return;

    const option = observerSelect.querySelector(`option[value="${playerId}"]`);
    if (option && !option.selected) {
      option.selected = true;
      observerSelect.dispatchEvent(new Event('change', { bubbles: true }));

      const form = document.querySelector('form');
      if (form) form.requestSubmit();

      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 100);
    }
  }

  function renderPlayerResults() {
    const searchTerm = document.getElementById('player-search-input').value.toLowerCase();
    const assignedIds = getAssignedPlayerIds();

    const filtered = allPlayers.filter(p => {
      if (searchTerm && !p.nickname.toLowerCase().includes(searchTerm)) return false;
      return true;
    });

    const container = document.getElementById('player-search-results');

    // Add "New Player" card at the top
    let html = `
      <div class="player-card p-2 bg-green-50 border border-green-300 rounded transition-colors cursor-pointer hover:bg-green-100"
           draggable="true"
           data-player-id="new"
           data-player-name="New Player (${newPlayerDefaults.ml_score})"
           ondragstart="handleNewPlayerDragStart(event)"
           ondragend="handlePlayerDragEnd(event)"
           onclick="assignNewPlayer(this)">
        <div class="flex justify-between items-center">
          <span class="font-medium text-sm text-green-700">+ New Player</span>
          <span class="text-xs text-green-600">${newPlayerDefaults.ml_score}</span>
        </div>
        <div class="text-xs text-green-600">Add unknown player</div>
      </div>
    `;

    html += filtered.slice(0, 50).map(p => {
      const isAssigned = assignedIds.has(String(p.id));
      const mlScoreColor = p.mlScore >= 55 ? 'text-green-600' : (p.mlScore <= 45 ? 'text-red-600' : 'text-gray-600');
      return `
        <div class="player-card p-2 bg-gray-50 border border-gray-200 rounded transition-colors ${isAssigned ? 'already-assigned' : ''}"
             draggable="${!isAssigned}"
             data-player-id="${p.id}"
             data-player-name="${p.nickname}"
             ondragstart="handlePlayerDragStart(event, ${p.id}, '${p.nickname}')"
             ondragend="handlePlayerDragEnd(event)"
             onclick="assignPlayer(${p.id}, this)">
          <div class="flex justify-between items-center">
            <span class="font-medium text-sm">${p.nickname}</span>
            <span class="text-xs ${mlScoreColor} font-medium">${p.mlScore || '-'}</span>
          </div>
          <div class="text-xs text-gray-500">
            <span class="text-green-600">${p.wins}W</span>/<span class="text-red-600">${p.losses}L</span>
            <span class="ml-1 text-gray-400">${p.games}g</span>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;

    document.getElementById('player-count').textContent =
      `Showing ${Math.min(filtered.length, 50)} of ${filtered.length} players`;
  }

  function assignPlayer(playerId, element) {
    if (element.classList.contains('already-assigned')) return;

    // Find first empty slot
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        setSelectValue(select, String(playerId));

        // Trigger form submit
        const form = document.querySelector('form');
        if (form) form.requestSubmit();

        // Update UI
        setTimeout(() => {
          renderPlayerResults();
          renderRecentPlayers();
          renderObservers();
        }, 100);
        return;
      }
    }

    // No empty slot - add as observer
    addObserver(playerId);
  }

  function assignNewPlayer(element) {
    // Find first empty slot and set it to "new player" mode
    const slots = document.querySelectorAll('[data-lobby-drag-target="playerSlot"]');
    for (const slot of slots) {
      const select = slot.querySelector('select');
      if (select && !select.value) {
        const slotIndex = slot.dataset.slotIndex;
        setNewPlayerSlot(slotIndex);
        return;
      }
    }
  }

  function setNewPlayerSlot(slotIndex) {
    // Clear the select value (no real player)
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Set the is_new_player hidden field
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '1';
    }

    // Update display to show "New Player" with bottom 5% ELO
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (cell) {
      const existingPlayer = cell.querySelector('.slot-player');
      const existingEmpty = cell.querySelector('.text-gray-400.italic');

      const html = `
        <span class="slot-player cursor-move px-2 py-1 bg-green-50 border border-green-300 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="new"
              data-player-name="New Player (${newPlayerDefaults.ml_score})"
              data-slot-index="${slotIndex}"
              data-is-new="true"
              data-ml-score="${newPlayerDefaults.ml_score}"
              ondragstart="handleSlotDragStart(event, 'new', 'New Player (${newPlayerDefaults.ml_score})', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          <span class="text-green-700">New Player</span>
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;

      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    }

    // Set ML Score and W/L to new player defaults
    const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
    const wlCell = document.getElementById('wl-' + slotIndex);

    if (mlScoreCell) mlScoreCell.innerHTML = `<span class="text-red-600 font-medium">${newPlayerDefaults.ml_score}</span>`;
    if (wlCell) wlCell.innerHTML = '<span class="text-green-600">0W</span>/<span class="text-red-600">0L</span>';

    // Mark this slot as a new player for prediction calculations
    const row = cell.closest('tr');
    if (row) row.dataset.isNewPlayer = 'true';

    // Submit the form to save the new player state
    const form = document.querySelector('form');
    if (form) form.requestSubmit();

    // Update averages and prediction
    updateAverageElos();
    updatePrediction();
  }

  function handleNewPlayerDragStart(e) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: 'new',
      playerName: `New Player (${newPlayerDefaults.ml_score})`,
      sourceType: 'new',
      isNew: true
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function setSelectValue(select, value) {
    select.value = value;

    // Clear is_new_player when assigning a real player
    const slotIndex = select.id.replace('player-select-', '');
    const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
    if (isNewPlayerField) {
      isNewPlayerField.value = '0';
    }

    // Remove new player marker from row
    const row = select.closest('tr');
    if (row) delete row.dataset.isNewPlayer;

    // Update searchable-select display
    const wrapper = select.previousElementSibling;
    if (wrapper && wrapper.classList.contains('searchable-select')) {
      const input = wrapper.querySelector('.searchable-select-input');
      if (input) {
        const selectedOption = select.options[select.selectedIndex];
        input.value = selectedOption ? selectedOption.text : '';
      }
    }

    // Trigger change and update W/L
    select.dispatchEvent(new Event('change', { bubbles: true }));
    const wlTarget = select.dataset.wlTarget;
    if (wlTarget && typeof updateWL === 'function') {
      updateWL(select, wlTarget);
    }
  }

  function refreshObserverSelect() {
    // No longer needed since we use a hidden select now
    // Kept for compatibility
  }

  function updateWL(select, targetId) {
    const option = select.options[select.selectedIndex];
    const wins = option.dataset.wins;
    const losses = option.dataset.losses;
    const mlScore = option.dataset.mlScore;
    const wlTarget = document.getElementById(targetId);
    const mlScoreTarget = document.getElementById(targetId.replace('wl-', 'ml-score-'));
    if (wins && losses) {
      wlTarget.innerHTML = '<span class="text-green-600">' + wins + 'W</span>/<span class="text-red-600">' + losses + 'L</span>';
    } else {
      wlTarget.innerHTML = '-';
    }
    if (mlScoreTarget && mlScore) {
      const score = parseFloat(mlScore);
      const colorClass = score >= 55 ? 'text-green-600' : (score <= 45 ? 'text-red-600' : 'text-gray-600');
      mlScoreTarget.innerHTML = `<span class="${colorClass} font-medium">${mlScore}</span>`;
    } else if (mlScoreTarget) {
      mlScoreTarget.innerHTML = '-';
    }
    updateAverageElos();
    updatePrediction();
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
  }

  function updateAverageElos() {
    // Recalculate average ML Score for each team
    [1, 2].forEach(teamNumber => {
      const rows = document.querySelectorAll(`tr.nested-fields[data-team="${teamNumber}"]`);
      let totalMlScore = 0;
      let count = 0;
      rows.forEach(row => {
        const select = row.querySelector('select');
        const isNewPlayer = row.dataset.isNewPlayer === 'true';

        if (isNewPlayer) {
          totalMlScore += newPlayerDefaults.ml_score;
          count++;
        } else if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            const mlScore = parseFloat(selectedOption.dataset.mlScore);
            if (!isNaN(mlScore)) {
              totalMlScore += mlScore;
              count++;
            }
          }
        }
      });
      const averageMlScore = count > 0 ? (totalMlScore / count).toFixed(1) : 0;

      // Find the average ML Score display for this team's tbody
      const tbody = document.querySelector(`tbody[data-controller="average-elo"]:nth-of-type(${teamNumber})`);
      if (tbody) {
        const mlValueTarget = tbody.querySelector('[data-average-elo-target="mlValue"]');
        if (mlValueTarget) {
          mlValueTarget.textContent = averageMlScore;
        }
      }
    });
  }

  function updatePrediction() {
    const rows = document.querySelectorAll('tr.nested-fields');
    let goodScores = [];
    let evilScores = [];

    rows.forEach(row => {
      const team = row.dataset.team;
      if (!team) return;

      const isNewPlayer = row.dataset.isNewPlayer === 'true';
      let mlScore = null;

      if (isNewPlayer) {
        mlScore = newPlayerDefaults.ml_score;
      } else {
        const select = row.querySelector('select');
        if (select) {
          const selectedOption = select.options[select.selectedIndex];
          if (selectedOption && selectedOption.dataset.mlScore) {
            mlScore = parseFloat(selectedOption.dataset.mlScore);
          }
        }
      }

      if (mlScore !== null && !isNaN(mlScore)) {
        if (team === '1') {
          goodScores.push(mlScore);
        } else if (team === '2') {
          evilScores.push(mlScore);
        }
      }
    });

    // Calculate prediction based on average ML scores
    // Higher ML score = better player, so we compare averages
    const goodAvg = goodScores.length > 0 ? goodScores.reduce((a, b) => a + b, 0) / goodScores.length : 50;
    const evilAvg = evilScores.length > 0 ? evilScores.reduce((a, b) => a + b, 0) / evilScores.length : 50;

    // Use logistic function to convert score difference to win probability
    // A 10-point ML score difference gives roughly 65/35 odds
    const scoreDiff = goodAvg - evilAvg;
    const goodExpected = 1 / (1 + Math.exp(-scoreDiff / 15));
    const goodPct = Math.round(goodExpected * 100);
    const evilPct = 100 - goodPct;

    const goodBar = document.getElementById('good-win-bar');
    const goodPctEl = document.getElementById('good-win-pct');
    const evilPctEl = document.getElementById('evil-win-pct');

    if (goodBar) goodBar.style.width = goodPct + '%';
    if (goodPctEl) goodPctEl.textContent = goodPct + '%';
    if (evilPctEl) evilPctEl.textContent = evilPct + '%';
  }

  // Drag handlers
  function handlePlayerDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'search'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function handleObserverDragStart(e, playerId, playerName) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'observer'
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight only player slots (not observer zone since they're already observers)
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
  }

  function handleSlotDragStart(e, playerId, playerName, slotIndex) {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      playerId: playerId,
      playerName: playerName,
      sourceType: 'slot',
      sourceIndex: slotIndex
    }));
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');

    // Highlight all drop zones
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.add('drop-zone-active');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.add('drop-zone-active');
  }

  function clearSlot(slotIndex) {
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      select.value = '';
      select.dispatchEvent(new Event('change', { bubbles: true }));

      // Clear the is_new_player hidden field
      const isNewPlayerField = document.getElementById('is-new-player-' + slotIndex);
      if (isNewPlayerField) {
        isNewPlayerField.value = '0';
      }

      // Update the cell display
      updateSlotDisplay(slotIndex, null, null);

      // Remove new player marker if present
      const cell = document.getElementById('player-cell-' + slotIndex);
      const row = cell?.closest('tr');
      if (row) delete row.dataset.isNewPlayer;

      // Trigger form submit
      const form = document.querySelector('form');
      if (form) form.requestSubmit();

      // Update all lists
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
        updateAverageElos();
        updatePrediction();
      }, 100);
    }
  }

  function updateSlotDisplay(slotIndex, playerId, playerName) {
    const cell = document.getElementById('player-cell-' + slotIndex);
    if (!cell) return;

    // Find existing slot-player span or empty slot text
    const existingPlayer = cell.querySelector('.slot-player');
    const existingEmpty = cell.querySelector('.text-gray-400.italic');

    if (playerId && playerName) {
      const html = `
        <span class="slot-player cursor-move px-2 py-1 bg-blue-50 border border-blue-200 rounded inline-flex items-center gap-2"
              draggable="true"
              data-player-id="${playerId}"
              data-player-name="${playerName}"
              data-slot-index="${slotIndex}"
              ondragstart="handleSlotDragStart(event, ${playerId}, '${playerName}', ${slotIndex})"
              ondragend="handlePlayerDragEnd(event)">
          ${playerName}
          <button type="button" onclick="clearSlot(${slotIndex})" class="text-gray-400 hover:text-red-500 text-sm leading-none">&times;</button>
        </span>
      `;
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      } else if (existingEmpty) {
        existingEmpty.outerHTML = html;
      }
    } else {
      const html = '<span class="text-gray-400 italic">Empty slot</span>';
      if (existingPlayer) {
        existingPlayer.outerHTML = html;
      }
    }

    // Update ML Score and W/L display
    const select = document.getElementById('player-select-' + slotIndex);
    if (select) {
      const option = select.options[select.selectedIndex];
      const mlScoreCell = document.getElementById('ml-score-' + slotIndex);
      const wlCell = document.getElementById('wl-' + slotIndex);

      if (mlScoreCell) {
        if (option && option.dataset.mlScore) {
          const score = parseFloat(option.dataset.mlScore);
          const colorClass = score >= 55 ? 'text-green-600' : (score <= 45 ? 'text-red-600' : 'text-gray-600');
          mlScoreCell.innerHTML = `<span class="${colorClass} font-medium">${option.dataset.mlScore}</span>`;
        } else {
          mlScoreCell.textContent = '-';
        }
      }
      if (wlCell) {
        if (option && option.dataset.wins && option.dataset.losses) {
          wlCell.innerHTML = `<span class="text-green-600">${option.dataset.wins}W</span>/<span class="text-red-600">${option.dataset.losses}L</span>`;
        } else {
          wlCell.textContent = '-';
        }
      }
    }
  }

  function handlePlayerDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('[data-lobby-drag-target="playerSlot"]').forEach(slot => {
      slot.classList.remove('drop-zone-active', 'drop-zone-hover');
    });
    const observerZone = document.querySelector('[data-lobby-drag-target="observerZone"]');
    if (observerZone) observerZone.classList.remove('drop-zone-active', 'drop-zone-hover');
  }

  // Expose functions to window for Stimulus controller
  window.setSelectValue = setSelectValue;
  window.refreshObserverSelect = refreshObserverSelect;
  window.renderPlayerResults = renderPlayerResults;
  window.renderRecentPlayers = renderRecentPlayers;
  window.renderObservers = renderObservers;
  window.addObserver = addObserver;
  window.removeObserver = removeObserver;
  window.clearSlot = clearSlot;
  window.updateSlotDisplay = updateSlotDisplay;
  window.updateAverageElos = updateAverageElos;
  window.updatePrediction = updatePrediction;
  window.handlePlayerDragStart = handlePlayerDragStart;
  window.handleObserverDragStart = handleObserverDragStart;
  window.handleSlotDragStart = handleSlotDragStart;
  window.handlePlayerDragEnd = handlePlayerDragEnd;
  window.handleNewPlayerDragStart = handleNewPlayerDragStart;
  window.assignNewPlayer = assignNewPlayer;
  window.setNewPlayerSlot = setNewPlayerSlot;

  // Event listeners
  document.getElementById('player-search-input').addEventListener('input', renderPlayerResults);

  // Also update when selects change
  document.addEventListener('change', (e) => {
    if (e.target.matches('select[name*="player_id"]') || e.target.id === 'observer-select') {
      setTimeout(() => {
        renderPlayerResults();
        renderRecentPlayers();
        renderObservers();
      }, 50);
    }
  });

  document.addEventListener('DOMContentLoaded', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
  });
  document.addEventListener('turbo:load', () => {
    renderPlayerResults();
    renderRecentPlayers();
    renderObservers();
    updateAverageElos();
    updatePrediction();
  });
</script>
